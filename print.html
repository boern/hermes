<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hermes (IBC Relayer CLI) Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Hermes (v0.2.0)</li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="relayer.html"><strong aria-hidden="true">1.1.</strong> What is Hermes?</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="features/matrix.html"><strong aria-hidden="true">2.1.</strong> Feature matrix</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pre_requisites.html"><strong aria-hidden="true">3.1.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.3.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">4.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/index.html"><strong aria-hidden="true">4.1.</strong> Local chains</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/gaia.html"><strong aria-hidden="true">4.1.1.</strong> Install Gaia</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/start.html"><strong aria-hidden="true">4.1.2.</strong> Start the local chains</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/identifiers.html"><strong aria-hidden="true">4.1.3.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/index.html"><strong aria-hidden="true">4.1.4.</strong> Connect the chains using relay paths</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/create-new-path.html"><strong aria-hidden="true">4.1.4.1.</strong> Create a new path</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/existing-path.html"><strong aria-hidden="true">4.1.4.2.</strong> Packet relaying on existing path</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/new-path.html"><strong aria-hidden="true">4.1.4.3.</strong> Packet relaying on new path</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/multiple-paths.html"><strong aria-hidden="true">4.1.4.4.</strong> Concurrent packet relaying on multiple paths</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/index.html"><strong aria-hidden="true">4.1.5.</strong> Connect the chains using raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/client.html"><strong aria-hidden="true">4.1.5.1.</strong> Configure clients</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/connection.html"><strong aria-hidden="true">4.1.5.2.</strong> Connection handshake</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/channel.html"><strong aria-hidden="true">4.1.5.3.</strong> Channel handshake</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/packet.html"><strong aria-hidden="true">4.1.5.4.</strong> Relay packets</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">5.</strong> Commands Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/global.html"><strong aria-hidden="true">5.1.</strong> Global options and JSON output</a></li><li class="chapter-item expanded "><a href="commands/keys/index.html"><strong aria-hidden="true">5.2.</strong> Keys</a></li><li class="chapter-item expanded "><a href="commands/setup-and-relaying/index.html"><strong aria-hidden="true">5.3.</strong> Path setup and streaming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/setup-and-relaying/clients.html"><strong aria-hidden="true">5.3.1.</strong> Clients</a></li><li class="chapter-item expanded "><a href="commands/setup-and-relaying/connections.html"><strong aria-hidden="true">5.3.2.</strong> Connections</a></li><li class="chapter-item expanded "><a href="commands/setup-and-relaying/channels.html"><strong aria-hidden="true">5.3.3.</strong> Channels</a></li><li class="chapter-item expanded "><a href="commands/setup-and-relaying/packets.html"><strong aria-hidden="true">5.3.4.</strong> Packet relaying</a></li></ol></li><li class="chapter-item expanded "><a href="commands/listen/index.html"><strong aria-hidden="true">5.4.</strong> Listen mode</a></li><li class="chapter-item expanded "><a href="commands/upgrade/index.html"><strong aria-hidden="true">5.5.</strong> Client upgrade</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/upgrade/test.html"><strong aria-hidden="true">5.5.1.</strong> Testing client upgrade</a></li></ol></li><li class="chapter-item expanded "><a href="commands/misbehaviour/index.html"><strong aria-hidden="true">5.6.</strong> Misbehaviour</a></li><li class="chapter-item expanded "><a href="commands/queries/index.html"><strong aria-hidden="true">5.7.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/queries/client.html"><strong aria-hidden="true">5.7.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="commands/queries/connection.html"><strong aria-hidden="true">5.7.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/queries/channel.html"><strong aria-hidden="true">5.7.3.</strong> Channel</a></li><li class="chapter-item expanded "><a href="commands/queries/packet.html"><strong aria-hidden="true">5.7.4.</strong> Packet</a></li></ol></li><li class="chapter-item expanded "><a href="commands/raw/index.html"><strong aria-hidden="true">5.8.</strong> Raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/raw/client.html"><strong aria-hidden="true">5.8.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="commands/raw/connection.html"><strong aria-hidden="true">5.8.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/raw/channel-open.html"><strong aria-hidden="true">5.8.3.</strong> Channel Open</a></li><li class="chapter-item expanded "><a href="commands/raw/channel-close.html"><strong aria-hidden="true">5.8.4.</strong> Channel Close</a></li><li class="chapter-item expanded "><a href="commands/raw/packet.html"><strong aria-hidden="true">5.8.5.</strong> Packet</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="help.html"><strong aria-hidden="true">6.</strong> Help</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">7.</strong> Glossary</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Hermes (IBC Relayer CLI) Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hermes-guide-v020" id="hermes-guide-v020">Hermes Guide (v0.2.0)</a></h1>
<p>This guide can help you setup, configure, and operate Hermes to transfer
packets between two IBC enabled chains.</p>
<h2><a class="header" href="#sections" id="sections">Sections</a></h2>
<p><strong><a href="./relayer.html">What is Hermes</a></strong></p>
<ul>
<li>Explains what Hermes is about.</li>
</ul>
<p><strong><a href="./features.html">Features</a></strong></p>
<ul>
<li>This section discusses what features to expect from Hermes, as well as a
comparison between the Cosmos Go relayer and Hermes.</li>
</ul>
<p><strong><a href="./getting_started.html">Getting Started</a></strong></p>
<ul>
<li>The getting started section can help you setup, configure, and run Hermes.</li>
</ul>
<p><strong><a href="./tutorials/index.html">Tutorials</a></strong></p>
<ul>
<li>This section provides some tutorials on how to operate and test Hermes.</li>
</ul>
<p><strong><a href="./commands/index.html">Commands Reference</a></strong></p>
<ul>
<li>The commands let you interact with Hermes using its command line interface.</li>
</ul>
<p><strong><a href="./help.html">Help</a></strong></p>
<ul>
<li>This part provides guidelines regarding troubleshooting and general resources
for getting help.</li>
</ul>
<p><strong><a href="./glossary.html">Glossary</a></strong></p>
<ul>
<li>This section provides some definitions of terms used throughout the guide</li>
</ul>
<hr />
<p><strong>Other References and Useful Links:</strong></p>
<ul>
<li><a href="https://github.com/informalsystems/ibc-rs">Hermes Github repository</a>
— The official Github repository for Hermes.</li>
<li><a href="https://github.com/cosmos/ics">IBC Github repository</a>
<ul>
<li>The official repository for the Inter-blockchain protocol (IBC).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h2>
<p>This project is undergoing heavy development, use at your own risk.</p>
<h1><a class="header" href="#what-is-hermes" id="what-is-hermes">What is Hermes?</a></h1>
<p>Hermes is a an open-source Rust implementation of a relayer for the <a href="https://cosmos.network/ibc">Inter-Blockchain Communication protocol</a> (IBC),
released under the <a href="https://crates.io/crates/ibc-relayer-cli">ibc-relayer-cli</a> crate.</p>
<p>The <strong>Inter-Blockchain Communication protocol</strong> is an end-to-end, connection-oriented,
state-ful protocol for reliable, ordered, and authenticated communication between modules
on separate distributed ledgers. <sup class="footnote-reference"><a href="#ibc">1</a></sup></p>
<p>An IBC <strong>relayer</strong> is an off-chain process responsible for relaying IBC datagrams between any two chains.
The way it does so is by scanning chain states, building transactions based on these states,
and submitting the transactions to the chains involved in the network.</p>
<p>The relayer is a central element in the IBC network architecture. This is because chain modules
in this architecture are not directly sending messages to each other over networking infrastructure,
but instead they create and store the data to be retrieved and used by a relayer to build the IBC datagrams.</p>
<p>We sometimes refer to Hermes as &quot;IBC Relayer CLI&quot;, to make it clear that this
is a relayer CLI (i.e., a binary) and distinguish from the relayer core library
(which is the crate called <a href="https://crates.io/crates/ibc-relayer"><code>ibc-relayer</code></a>).</p>
<p>Hermes is actively developed and maintained by <a href="https://informal.systems">Informal Systems</a> in the <a href="https://github.com/informalsystems/ibc-rs">ibc-rs</a> repository.</p>
<div class="footnote-definition" id="ibc"><sup class="footnote-definition-label">1</sup>
<p><a href="https://arxiv.org/pdf/2006.15918.pdf">The Interblockchain Communication Protocol: An Overview</a></p>
</div>
<h1><a class="header" href="#features" id="features">Features</a></h1>
<p>This section includes a summary of the supported and planned features.
A feature matrix and comparison between the Rust and Go relayer implementations can be found in the <a href="./features/matrix.html">Feature Matrix</a></p>
<h2><a class="header" href="#supported-features" id="supported-features">Supported Features</a></h2>
<ul>
<li>
<p>Basic features</p>
<ul>
<li>create and update clients</li>
<li>establish connections with new or existing clients</li>
<li>establish channels with new or existing connection</li>
<li>channel closing handshake</li>
<li>relay packets, acknowledgments, timeout and timeout-on-close packets, with zero or non-zero delay.</li>
<li>queries for all objects</li>
</ul>
</li>
<li>
<p>Packet relaying over:</p>
<ul>
<li>new path</li>
<li>single specified path</li>
<li>multiple paths configured in <code>config.toml</code></li>
</ul>
</li>
<li>
<p>Restart support</p>
<ul>
<li>clear packets on relayer restart when started for a single path</li>
</ul>
<blockquote>
<p>clear packets in multi-path mode not fully supported yet</p>
</blockquote>
</li>
<li>
<p>Client upgrade</p>
<ul>
<li>upgrading clients after a counterparty chain has performed an upgrade for IBC breaking changes</li>
</ul>
</li>
<li>
<p>Packet delay:</p>
<ul>
<li>establish path over non-zero delay connection</li>
<li>relay all packets with the specified delay</li>
</ul>
</li>
<li>
<p>Monitor and submit misbehaviour for clients</p>
<ul>
<li>monitor client updates for misbehaviour (fork and BFT time violation)</li>
<li>submit misbehaviour evidence to the on-chain IBC client.</li>
</ul>
<blockquote>
<p>misbehaviour submission to full node not yet supported</p>
</blockquote>
</li>
<li>
<p>Individual commands that build and send transactions for:</p>
<ul>
<li>creating and updating IBC Tendermint light clients</li>
<li>aending connection open handshake datagrams</li>
<li>sending channel open handshake datagrams</li>
<li>sending channel closing handshake datagrams</li>
<li>initiating a cross chain transfer (mainly for testing)</li>
<li>relaying sent packets, acknowledgments and timeouts</li>
<li>client upgrade</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#upcoming--unsupported-features" id="upcoming--unsupported-features">Upcoming / Unsupported Features</a></h2>
<p>Planned features:</p>
<ul>
<li>Connection handshake for existing connection that is not in <code>Open</code> state</li>
<li>Channel handshake for existing channel that is not in <code>Open</code> state</li>
<li>Clear pending packets in multi path mode</li>
<li>Full Passive mode: relay from all IBC events</li>
<li>Relayer support for management application (add RPC server)</li>
</ul>
<p>Not planned:</p>
<ul>
<li>Relayer management application</li>
<li>Create clients with user chosen parameters (such as UpgradePath)</li>
<li>Use IBC light clients other than Tendermint such as Solo Machine</li>
<li>Support non cosmos-SDK chains</li>
</ul>
<h1><a class="header" href="#feature-matrix" id="feature-matrix">Feature Matrix</a></h1>
<p>This section gives more details about the features and implementation status 
of Hermes in comparison with the <a href="https://github.com/cosmos/relayer">cosmos-go-relayer</a>.</p>
<p><strong>Legend</strong>:</p>
<table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody>
<tr><td>❌</td><td>feature not supported</td></tr>
<tr><td>✅</td><td>feature is supported</td></tr>
<tr><td><code>Chain</code></td><td>chain related</td></tr>
<tr><td><code>Cl</code></td><td>client related</td></tr>
<tr><td><code>Conn</code></td><td>connection related</td></tr>
<tr><td><code>Chan</code></td><td>channel related</td></tr>
<tr><td><code>.._Handshake_..</code></td><td>can execute all transactions required to finish a handshake from a single command</td></tr>
<tr><td><code>.._&lt;msg&gt;_A</code></td><td>building and sending <code>msg</code> from a command that scans chain state</td></tr>
<tr><td><code>.._&lt;msg&gt;_P</code></td><td>building and sending <code>msg</code> from IBC event; doesn't apply to <code>.._Init</code> and <code>FT_Transfer</code> features</td></tr>
</tbody></table>
<p><strong>Feature comparison between Hermes and the Go relayer</strong> </p>
<table><thead><tr><th>Features \      Status</th><th align="center">Hermes</th><th align="center">Cosmos Go</th><th align="left">Feature Details</th></tr></thead><tbody>
<tr><td>Restart</td><td align="center">✅</td><td align="center">✅</td><td align="left">replays any IBC events that happened before restart</td></tr>
<tr><td>Multiple_Paths</td><td align="center">✅</td><td align="center">✅</td><td align="left">relays on multiple paths concurrently</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Connection Delay</td><td align="center">✅</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Cl_Misbehavior</td><td align="center">✅</td><td align="center">❌</td><td align="left">monitors and submits IBC client misbehavior</td></tr>
<tr><td>Packet Delay</td><td align="center">✅</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Chan_Unordered</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Ordered</td><td align="center">✅</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Cl_Tendermint_Create</td><td align="center">✅</td><td align="center">✅</td><td align="left">tendermint light client creation</td></tr>
<tr><td>Cl_Tendermint_Update</td><td align="center">✅</td><td align="center">✅</td><td align="left">tendermint light client update</td></tr>
<tr><td>Cl_Tendermint_Upgrade</td><td align="center">✅</td><td align="center">✅</td><td align="left">tendermint light client upgrade</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Conn_Open_Handshake_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Open_Handshake_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Chan_Open_Handshake_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Open_Handshake_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Chan_Close_Handshake_P</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Close_Handshake_A</td><td align="center">✅</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>FT_Transfer</td><td align="center">✅</td><td align="center">✅</td><td align="left">can submit an ICS-20 fungible token transfer message</td></tr>
<tr><td>Packet_Recv_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Recv_P</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Timeout_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Timeout_P</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_TimeoutClose_A</td><td align="center">✅</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td>Packet_TimeoutClose_P</td><td align="center">✅</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Cl_Non_Tendermint</td><td align="center">❌</td><td align="center">❌</td><td align="left">supports non tendermint IBC light clients</td></tr>
<tr><td>Chain_Non_Cosmos</td><td align="center">❌</td><td align="center">❌</td><td align="left">supports non cosmos-SDK chains</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Mgmt_Static</td><td align="center">✅</td><td align="center">✅</td><td align="left">provides means for configuration prior to being started</td></tr>
<tr><td>Mgmt_Dynamic</td><td align="center">❌</td><td align="center">❌</td><td align="left">provides means for configuration and monitoring during runtime</td></tr>
</tbody></table>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>In order to run Hermes, please make sure you have all the 
<a href="./pre_requisites.html">pre-requisites</a> installed on your machine.</p>
<p>Once you have these pre-requisites, you can
<a href="./installation.html">build and run Hermes</a>.</p>
<blockquote>
<p>The instructions in this guide have been tested on <code>Linux</code> and <code>MacOS</code> 
environments. Most of the commands should work on both environments. Even 
though you can build and run the relayer on <code>Windows</code> (since we develop it 
in Rust and it supports cross platform compilation) we have not tested the 
relayer on <code>Windows</code> and we do not support this operating system at this time.</p>
</blockquote>
<h1><a class="header" href="#pre-requisites" id="pre-requisites">Pre-requisites</a></h1>
<h2><a class="header" href="#1-rust" id="1-rust">1. Rust</a></h2>
<p>The IBC Relayer is developed with the <a href="https://www.rust-lang.org">Rust</a> programming language. In order to build and run the relayer you need to install and configure <code>Rust</code> on your machine.</p>
<h3><a class="header" href="#fresh-rust-installation" id="fresh-rust-installation">Fresh Rust installation</a></h3>
<p>For instructions on how to install <code>Rust</code> on your machine please follow the official <a href="https://www.rust-lang.org/tools/install"><code>Notes about Rust Installation</code></a>.</p>
<p>The provided instructions will install all the Rust toolchain including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> that are required to build the project.</p>
<h3><a class="header" href="#version-requirements" id="version-requirements">Version requirements</a></h3>
<p>Hermes is developed and tested using the latest version of Rust, <code>1.49</code> at 
the moment. To check that your toolchain is up-to-date run:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>In case you already had installed the Rust toolchain in the past, you can 
update your installation by running <code>rustup update</code>.</p>
<h3><a class="header" href="#testing-the-installation" id="testing-the-installation">Testing the installation</a></h3>
<p>After you install the <code>Rust</code> toolchain you can execute the following command:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<p>This should display the <code>cargo</code> version and confirm the proper installation.</p>
<h2><a class="header" href="#2-golang" id="2-golang">2. Golang</a></h2>
<p>You will also need the <strong>Go</strong> programming language installed and configured on your machine. This is a requirement for the the section <a href="./tutorials/local-chains/gaia.html">Installing Gaia</a> in the <a href="./tutorials/local-chains/index.html">Two Local Chains</a> tutorial.</p>
<p>To install and configure Golang on your machine please follow the <a href="https://golang.org/doc/install">Golang official documentation</a>.</p>
<h2><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h2>
<p>Next, go to the <a href="./installation.html">Installation</a> section to learn how to build Hermes.</p>
<h1><a class="header" href="#install-the-relayer" id="install-the-relayer">Install the relayer</a></h1>
<p>There are two main approaches for obtaining Hermes:</p>
<ol>
<li>
<p>Installation:</p>
<ol>
<li>If you are running on a Unix machine (Linux/MacOS), then the simplest
option is to <a href="installation.html#install-by-downloading">download the latest binary</a>.</li>
<li>You can also install via <a href="installation.html#install-via-cargo">Cargo</a>.</li>
</ol>
</li>
<li>
<p>Alternatively, <a href="installation.html#build-from-source">build Hermes directly from source</a>.</p>
</li>
</ol>
<h2><a class="header" href="#install-by-downloading" id="install-by-downloading">Install by downloading</a></h2>
<p>Simply head to the GitHub <a href="https://github.com/informalsystems/ibc-rs/releases">Releases</a> page and download the latest
version of Hermes binary matching your platform:</p>
<ul>
<li>MacOS: <code>hermes-v0.2.0-x86_64-apple-darwin.tar.gz</code> (or .zip),</li>
<li>Linux: <code>hermes-v0.2.0-x86_64-unknown-linux-gnu.tar.gz</code> (or .zip).</li>
</ul>
<p>The step-by-step instruction below should carry you through the whole process:</p>
<ol>
<li>
<p>Make the directory where we'll place the binary:</p>
<pre><code class="language-shell">mkdir -p $HOME/.hermes/bin
</code></pre>
</li>
<li>
<p>Extract the binary archive:</p>
<pre><code class="language-shell">tar -C $HOME/.hermes/bin/ -vxzf $ARCHIVE_NAME
</code></pre>
</li>
<li>
<p>Update your path, by adding this line in your <code>.bashrc</code> or <code>.zshrc</code> shell
configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.hermes/bin:$PATH&quot;
</code></pre>
</li>
</ol>
<blockquote>
<p>NOTE: The binary may be initially prevented from running if you're
on MacOS.
See the <a href="https://support.apple.com/en-gb/HT202491">&quot;Open Anyway&quot; instructions from this support forum</a>
if that is the case.</p>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.2.0
</code></pre>
<h2><a class="header" href="#install-via-cargo" id="install-via-cargo">Install via Cargo</a></h2>
<blockquote>
<p>NOTE: This approach assumes you have installed all
the <a href="./pre_requisites.html">pre-requisites</a> on your machine.</p>
</blockquote>
<p>Hermes is packaged in the <code>ibc-relayer-cli</code> Rust crate.
To install the latest release of Hermes, run the following command in a terminal:</p>
<pre><code class="language-shell">cargo install ibc-relayer-cli --bin hermes --locked
</code></pre>
<p>This will download and build the crate <code>ibc-relayer-cli</code>, and install the 
<code>hermes</code> binary in <code>$HOME/.cargo/bin</code>.</p>
<blockquote>
<p>If you have not installed Rust and Cargo via <a href="https://rustup.rs">rustup.rs</a>, you may need to
add the <code>$HOME/.cargo/bin</code> directory to your <code>PATH</code> environment variable.
For most shells, this can be done by adding the following line to your
<code>.bashrc</code> or <code>.zshrc</code> configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.2.0
</code></pre>
<h2><a class="header" href="#build-from-source" id="build-from-source">Build from source</a></h2>
<h3><a class="header" href="#clone-the-repository" id="clone-the-repository">Clone the repository</a></h3>
<p>Open a terminal and clone the following <code>ibc-rs</code> repository:</p>
<pre><code class="language-shell">git clone https://github.com/informalsystems/ibc-rs.git`
</code></pre>
<p>Change to the repository directory</p>
<pre><code class="language-shell">cd ibc-rs
</code></pre>
<h3><a class="header" href="#checkout-the-latest-release" id="checkout-the-latest-release">Checkout the latest release</a></h3>
<p>Go to the <a href="https://github.com/informalsystems/ibc-rs/releases">ibc-rs releases</a> page to see what is the most recent release.</p>
<p>Then checkout the release, for example if the most recent release is <code>v0.2.0</code> then execute the command:</p>
<pre><code class="language-shell">git checkout v0.2.0
</code></pre>
<h3><a class="header" href="#building-with-cargo-build" id="building-with-cargo-build">Building with <code>cargo build</code></a></h3>
<p>This command builds all the crates from the <a href="https://github.com/informalsystems/ibc-rs"><strong><code>ibc-rs</code></strong></a> repository, namely: the <a href="https://github.com/informalsystems/ibc-rs/tree/master/modules"><strong><code>ibc</code></strong></a> modules crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer"><strong><code>ibc-relayer</code></strong></a> crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/proto"><strong><code>ibc-proto</code></strong></a> crate, and the <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer-cli"><strong><code>ibc-relayer-cli</code></strong></a> crate.
The last of these crates contains the <code>hermes</code> binary.</p>
<pre><code class="language-shell">cargo build --release --bin hermes
</code></pre>
<p>If the build is successful, the <code>hermes</code> executable will be located in the following location:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<p><strong>Troubleshooting</strong>:
In case the <code>cargo build</code> command above fails, as a first course of action we
recommend trying to run the same command with the additional <code>locked</code> flag:</p>
<pre><code class="language-shell">cargo build --release --bin hermes --locked
</code></pre>
<h3><a class="header" href="#running-for-the-first-time" id="running-for-the-first-time">Running for the first time</a></h3>
<p>If you run the <code>hermes</code> without any additional parameters you should see the usage and help information:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<pre><code>hermes 0.2.0
Informal Systems &lt;hello@informal.systems&gt;

USAGE:
    hermes &lt;SUBCOMMAND&gt;

SUBCOMMANDS:
    help       Get usage information
    keys       Manage keys in the relayer for each chain
    start      Start the relayer
    channel    Channel functionality for managing channels
    query      Query state from chain
    tx         Create and send IBC transactions
    listen     Listen to and display IBC events emitted by a chain
    version    Display version information
</code></pre>
<h3><a class="header" href="#creating-an-alias-for-the-executable" id="creating-an-alias-for-the-executable">Creating an alias for the executable</a></h3>
<p>It might be easier to create an alias for <code>hermes</code> so you can just run it by specifying the executable name instead of the whole path. In order to create an alias execute the following command:</p>
<pre><code class="language-shell">alias hermes='cargo run --release --bin hermes --'
</code></pre>
<h3><a class="header" href="#next-steps-1" id="next-steps-1">Next Steps</a></h3>
<p>Go to the <a href="./config.html"><code>Configuration</code></a> section to learn how to create a configuration file to be used by Hermes.</p>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>In order to run Hermes, you will need to have a configuration file.</p>
<p>The format supported for the configuration file is <a href="https://toml.io/en/">TOML</a>.</p>
<p>By default, Hermes expects the configuration file to be located at <code>$HOME/.hermes/config.toml</code>.</p>
<p>This can be overridden by supplying the <code>-c</code> flag when invoking <code>hermes</code>, before the
name of the command to run, eg. <code>hermes -c my_config.toml query connection channels ibc-1 connection-1</code>.</p>
<blockquote>
<p>The current version of Hermes does not support managing the configuration file programmatically.
You will need to use a text editor to create the file and add content to it.</p>
</blockquote>
<pre><code class="language-bash">hermes [-c CONFIG_FILE] COMMAND
</code></pre>
<h2><a class="header" href="#sections-1" id="sections-1">Sections</a></h2>
<p>The configuration file must have one <code>global</code> section, and one <code>chains</code> section for each chain.</p>
<h3><a class="header" href="#global" id="global"><code>[global]</code></a></h3>
<p>The global section has parameters that apply globally to the relayer operation.</p>
<h4><a class="header" href="#parameters" id="parameters">Parameters</a></h4>
<ul>
<li>
<p><strong>strategy</strong>: Specify the strategy to be used by the relayer. Currently only <code>naive</code> is supported.</p>
</li>
<li>
<p><strong>log_level</strong>: Specify the verbosity for the relayer logging output. Valid options are 'error', 'warn', 'info', 'debug', 'trace'. Default value is <code>info</code>.
For more information on parametrizing the log output, see the section
<a href="./help.html#parametrizing-the-log-output-level">help/log-level</a>.</p>
</li>
</ul>
<p>Here is an example for the <code>global</code> section:</p>
<pre><code class="language-toml">[global]
strategy = 'naive'
log_level = 'info'
</code></pre>
<h3><a class="header" href="#chains" id="chains"><code>[[chains]]</code></a></h3>
<p>A <code>chains</code> section includes parameters related to a chain and the full node to which the relayer can send transactions and queries.</p>
<h4><a class="header" href="#parameters-1" id="parameters-1">Parameters</a></h4>
<ul>
<li>
<p><strong>id</strong>: Specify the chain ID. For example <code>ibc-0</code></p>
</li>
<li>
<p><strong>rpc_addr</strong>: Specify the RPC address and port where the chain RPC server listens on. For example <code>http://localhost:26657</code></p>
</li>
<li>
<p><strong>grpc_addr</strong>: Specify the GRPC address and port where the chain GRPC server listens on. For example <code>http://localhost:9090</code></p>
</li>
<li>
<p><strong>websocket_addr</strong>: Specify the WebSocket address and port where the chain WebSocket server listens on. For example <code>ws://localhost:26657/websocket</code></p>
</li>
<li>
<p><strong>rpc_timeout</strong>: Specify the maximum amount of time (duration) that the RPC requests should take before timing out. Default value is <code>10s</code> (10 seconds).</p>
</li>
<li>
<p><strong>account_prefix</strong>: Specify the prefix used by the chain. For example <code>cosmos</code></p>
</li>
<li>
<p><strong>key_name</strong>: Specify the name of the private key JSON file. This is the filename for the private key used to sign transactions on this chain. Don't specify the file extension, for example if the filename for the private key is <code>testkey.json</code>, specify only <code>testkey</code> for this parameter.</p>
</li>
<li>
<p><strong>store_prefix</strong>: Specify the store prefix used by the on-chain IBC modules. For example <code>ibc</code>.</p>
</li>
<li>
<p><strong>gas</strong>: Specify the maximum amount of gas to be used as the gas limit for a transaction. Default value is <code>300000</code></p>
</li>
<li>
<p><strong>fee_denom</strong>: Specify the denom to be used in the fee for a transaction.</p>
</li>
<li>
<p><strong>fee_amount</strong>: Specify the amount value to be used in the fee for a transaction. Default value is <code>1000</code></p>
</li>
<li>
<p><strong>clock_drift</strong>: Specify the maximum amount of time to tolerate a clock drift. The clock drift parameter defines how much new (untrusted) header's Time can drift into the future. Default value is <code>5s</code></p>
</li>
<li>
<p><strong>trusting_period</strong>: Specify the amount of time to be used as the trusting period. It should be significantly less than the unbonding period (e.g. unbonding period = 3 weeks, trusting period = 2 weeks). Default value is <code>14days</code> (336 hours)</p>
</li>
</ul>
<p>For example if you want to add a configuration for a chain named <code>ibc-0</code>:</p>
<pre><code class="language-toml">[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://localhost:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'
</code></pre>
<h3><a class="header" href="#adding-private-keys" id="adding-private-keys">Adding Private Keys</a></h3>
<p>For each chain configured you need to add a private key for that chain in order to submit <a href="./commands/raw/index.html">transactions</a>, please refer to the <a href="./commands/keys/index.html">Keys</a> sections in order to learn how to add the private keys that are used by the relayer.</p>
<h3><a class="header" href="#example-configuration-file" id="example-configuration-file">Example configuration file</a></h3>
<p>Here is a full example of a configuration file with two chains configured:</p>
<pre><code class="language-toml">[global]
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://localhost:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://localhost:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'
</code></pre>
<h3><a class="header" href="#next-steps-2" id="next-steps-2">Next Steps</a></h3>
<p>Now that you learned how to build the relayer and how to create a configuration file, you can go to the <a href="./tutorials/local-chains/index.html"><code>Two Chains</code></a> tutorial to learn how to perform some local testing connecting the relayer to two local chains.</p>
<h1><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h1>
<p>This section includes tutorials for some common relayer uses cases and commands. You can also refer to the <a href="tutorials/../commands/index.html">Commands Reference</a> section to learn more about individual commands.</p>
<h2><a class="header" href="#basic-tutorials" id="basic-tutorials">Basic tutorials</a></h2>
<p><strong><a href="tutorials/./local-chains/index.html">Two Local Chains</a></strong></p>
<p>In this tutorial you will learn how to start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and start relaying packets between them.</p>
<h1><a class="header" href="#tutorial-relayer-with-two-local-chains" id="tutorial-relayer-with-two-local-chains">Tutorial: Relayer with two local chains</a></h1>
<p>In this tutorial we will show how you can test the relayer against two chains, we provide a script that can start two separate chains and configure them automatically. This is the easiest way to get started.</p>
<p>The script starts two <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Follow the steps in this tutorial section starting with the <a href="tutorials/local-chains/./gaia.html">Install Gaia</a> section.# Local chains</p>
<h1><a class="header" href="#install-gaia" id="install-gaia">Install Gaia</a></h1>
<p>The script to start the chains requires gaia to be installed.</p>
<blockquote>
<p><strong>NOTE</strong>: This assumes you have <code>Golang</code> programming language installed on 
your machine. If not, please ensure you install before proceeding. See 
more details in the <a href="tutorials/local-chains/../../pre_requisites.html#2-golang">Pre-requisites</a> section.</p>
</blockquote>
<h4><a class="header" href="#clone-gaia" id="clone-gaia">Clone gaia</a></h4>
<p>Clone the repository from Github:</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/gaia.git ~/go/src/github.com/cosmos/gaia
</code></pre>
<h4><a class="header" href="#build-and-install" id="build-and-install">Build and Install</a></h4>
<p>Run the <code>make</code> command to build and install <code>gaiad</code></p>
<pre><code class="language-shell">cd ~/go/src/github.com/cosmos/gaia
git checkout v4.2.0
make install
</code></pre>
<p>If the command above is successful you can run the following command to ensure it was properly installed:</p>
<pre><code class="language-shell">$ gaiad version --log_level error --long | head -n4
name: gaia
server_name: gaiad
version: v4.2.0
commit: 535be14a8bdbfeb0d950914b5baa2dc72c6b081c
</code></pre>
<h2><a class="header" href="#next-steps-3" id="next-steps-3">Next Steps</a></h2>
<p>In the next section you will learn how to <a href="tutorials/local-chains/./start.html">start two local chains</a></p>
<h1><a class="header" href="#start-the-local-chains" id="start-the-local-chains">Start the local chains</a></h1>
<p>To start the local chains, open a terminal and navigate to the <code>ibc-rs</code> repository folder</p>
<pre><code class="language-bash">cd ibc-rs
</code></pre>
<h3><a class="header" href="#stop-existing-gaiad-processes" id="stop-existing-gaiad-processes">Stop existing <code>gaiad</code> processes</a></h3>
<p>If this is not the first time you are running the script, you can manually stop the two gaia instances executing the following command to kill all <code>gaiad</code> processes:</p>
<pre><code class="language-shell">killall gaiad
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 26657 or port 9090), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<h3><a class="header" href="#configuration-file" id="configuration-file">Configuration file</a></h3>
<p>In order to run the script, you will need a <code>TOML</code> configuration file to be passed as a parameter. Please check the <a href="tutorials/local-chains/../../config.html"><code>Configuration</code></a> section for more information about the relayer configuration file.</p>
<p>The following configuration file in the <code>ibc-rs</code> repository folder can be used for running the local chains:</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://127.0.0.1:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 3000000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://127.0.0.1:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 3000000
fee_denom = 'stake'
fee_amount = 1000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

</code></pre>
<h4><a class="header" href="#saving-the-configuration-file" id="saving-the-configuration-file">Saving the configuration file</a></h4>
<h5><a class="header" href="#create-the-configtoml-file" id="create-the-configtoml-file">Create the config.toml file</a></h5>
<pre><code class="language-shell">mkdir -p $HOME/.hermes &amp;&amp; touch $HOME/.hermes/config.toml
</code></pre>
<h5><a class="header" href="#add-content-to-the-configuration-file" id="add-content-to-the-configuration-file">Add content to the configuration file:</a></h5>
<p>You can use your preferred text editor. If using <code>vi</code> you can run:</p>
<pre><code class="language-shell">vi ~/.hermes/config.toml
</code></pre>
<p>Then just <strong><code>copy</code></strong> the content for <code>config.toml</code> above and <strong><code>paste</code></strong> into this file.</p>
<h3><a class="header" href="#running-the-script-to-start-the-chains" id="running-the-script-to-start-the-chains">Running the script to start the chains</a></h3>
<p>From the <code>ibc-rs</code> repository folder run the following script with the parameters below to start the chains (<code>ibc-0</code> and <code>ibc-1</code>)
and import the signing keys into the keyring:</p>
<pre><code class="language-bash">./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the script above prompts you to delete the data folder just answer <strong>'yes'</strong></p>
</blockquote>
<p>The script configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other <strong><code>ibc-1</code></strong></p>
<pre class="mermaid">graph TD
    A[dev-env] --&gt;|run| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| F[ibc-1]
</pre>
<p>If the script runs successfully you should see a message similar to the one below in the terminal:</p>
<pre><code class="language-shell">GAIA VERSION INFO: v4.2.0
Generating gaia configurations...
Creating gaiad instance: home=./data | chain-id=ibc-0 | p2p=:26656 | rpc=:26657 | profiling=:6060 | grpc=:9090 | samoleans=:100000000000
Change settings in config.toml file...
Start gaia on grpc port: 9090...
Balances for validator 'cosmos1kx8dmaav2k3gjyqr80f6ddaf94v5yujpefu8j6' @ 'tcp://localhost:26657'
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Balances for user 'cosmos1n33qt980aml6q8e2ky85g3dn98eh6fghg7cn6y' @ 'tcp://localhost:26657'
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Creating gaiad instance: home=./data | chain-id=ibc-1 | p2p=:26556 | rpc=:26557 | profiling=:6061 | grpc=:9091 | samoleans=:100000000000
Change settings in config.toml file...
Start gaia on grpc port: 9091...
Balances for validator 'cosmos188qk2p3qr7rjkequjjmpx0frcc65p6dltmml0x' @ 'tcp://localhost:26557'
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Balances for user 'cosmos1xkvpgw8dng3zr2au3n86u8e3h249355vg7jaef' @ 'tcp://localhost:26557'
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
ibc-0 initialized. Watch file /Users/ancaz/rust/ibc-rs/data/ibc-0.log to see its execution.
ibc-1 initialized. Watch file /Users/ancaz/rust/ibc-rs/data/ibc-1.log to see its execution.
Building the Rust relayer...
Importing keys...
Success: Added key testkey (cosmos1n33qt980aml6q8e2ky85g3dn98eh6fghg7cn6y) on ibc-0 chain
Success: Added key testkey (cosmos1xkvpgw8dng3zr2au3n86u8e3h249355vg7jaef) on ibc-1 chain
Done!
</code></pre>
<h3><a class="header" href="#data-directory" id="data-directory">Data directory</a></h3>
<p>The script creates a <strong><code>data</code></strong> directory in the current directory in order. The <strong><code>data</code></strong> directory contains the chain stores and configuration files.</p>
<p>The <strong><code>data</code></strong> directory has a tree structure similar to the one below:</p>
<pre><code class="language-shell">data
├── ibc-0
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── key_seed.json
│   └── validator_seed.json
├── ibc-0.log
├── ibc-1
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── key_seed.json
│   └── validator_seed.json
└── ibc-1.log

</code></pre>
<blockquote>
<p><strong>Tip</strong>: You can use the command <code>tree ./data/ -L 2</code> to view the folder structure above:</p>
</blockquote>
<h3><a class="header" href="#homehermes-directory" id="homehermes-directory">$HOME/.hermes directory</a></h3>
<p>By the default <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder.</p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="tutorials/local-chains/../../commands/keys/index.html">Keys</a> section.</p>
<p>After executing the <strong><code>dev-env</code></strong> script, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       └── testkey.json
    └── ibc-1
        └── keyring-test
            └── testkey.json
</code></pre>
<h4><a class="header" href="#next-steps-4" id="next-steps-4">Next Steps</a></h4>
<p><a href="tutorials/local-chains/./identifiers.html">The next section</a> describes how identifers for clients, connections and channels
are allocated, and will walk you through how to pre-allocate some identifers
to help matching them with their corresponding chains for the purpose of this tutorial.</p>
<h1><a class="header" href="#identifiers" id="identifiers">Identifiers</a></h1>
<p>A chain allocates identifiers when it creates clients, connections and channels. These identifiers can subsequently be used to refer to existing clients, connections and channels.</p>
<blockquote>
<p>NOTE: If you want to ensure you get the same identifiers while following the tutorials, run the each of the three commands below <strong>once</strong> on <code>ibc-1</code>. This will ensure that when going through the tutorial, a second channel on <code>ibc-1</code> with identifier <code>channel-1</code> will created.</p>
</blockquote>
<p>Chains allocate identifiers using a chain specific allocation scheme. Currently, <em>cosmos-sdk</em> implementation uses the follow identifiers:</p>
<h3><a class="header" href="#1-client-identifiers" id="1-client-identifiers">1. Client Identifiers</a></h3>
<p><strong><code>07-tendermint-&lt;n&gt;</code></strong> for tendermint clients</p>
<p>For example <code>07-tendermint-0</code> is assigned to the first client created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height {
               revision: 1,
               height: 103,
           },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height {
               revision: 0,
               height: 112,
           },
       },
   ),
)
<span class="boring">}
</span></code></pre></pre>
<p>We will create a second client on <code>ibc-1</code> with identifier <code>07-tendermint-1</code> in the client tutorial.</p>
<h3><a class="header" href="#2-connection-identifiers" id="2-connection-identifiers">2. Connection Identifiers</a></h3>
<p><strong><code>connection-&lt;n&gt;</code></strong> for connections</p>
<p>For example <code>connection-0</code> is assigned to the first connection created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-1 ibc-0 07-tendermint-0 07-tendermint-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 119,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>We will create a second connection on <code>ibc-1</code> with identifier <code>connection-1</code> in the connection tutorial.</p>
<h3><a class="header" href="#3-channel-identifiers" id="3-channel-identifiers">3. Channel Identifiers</a></h3>
<p><code>channel-&lt;n&gt;</code> for channels</p>
<p>For example <code>channel-0</code> is assigned to the first channel created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-1 ibc-0 connection-0 transfer transfer
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 225,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>In the following tutorials the <strong><code>ibc-0</code></strong> and <strong><code>ibc-1</code></strong> chains are setup and configured. </p>
<p>For clarity, the tutorials run on a setup where the identifiers allocated to the client, connection and channel on <strong><code>ibc-0</code></strong> are <strong><code>07-tendermint-0</code></strong>, <strong><code>connection-0</code></strong> and <strong><code>channel-0</code></strong> respectively. Identifiers allocated to the client, connection and channel on <strong><code>ibc-1</code></strong> are <strong><code>07-tendermint-1</code></strong>, <strong><code>connection-1</code></strong> and <strong><code>channel-1</code></strong> respectively.</p>
<p>Before going over the next sections, please ensure the commands above are executed.</p>
<h3><a class="header" href="#next-steps-5" id="next-steps-5">Next Steps</a></h3>
<p>The following sections describe the commands to connect and relay packets between two chains. You can:</p>
<ol>
<li>use a <a href="tutorials/local-chains/./relay-paths/index.html">simplified approach</a> for managing relaying paths, or</li>
<li>use <a href="tutorials/local-chains/./raw/index.html">individual (raw) transactions</a> to create
all the necessary chain objects (clients, connections, channels) and relay packets.</li>
</ol>
<h1><a class="header" href="#connect-the-chains-using-relay-paths" id="connect-the-chains-using-relay-paths">Connect the chains using relay paths</a></h1>
<p>A relay path refers to a specific channel used to interconnect two chains and over which packets are being sent.</p>
<p>Hermes can be started to listen for packet events on the two ends of a path and relay packets. This can be done over a new or existing path.</p>
<ul>
<li><a href="tutorials/local-chains/relay-paths/./create-new-path.html">Create a new path</a></li>
<li><a href="tutorials/local-chains/relay-paths/./existing-path.html">Packet relaying on existing path</a></li>
<li><a href="tutorials/local-chains/relay-paths/./new-path.html">Packet relaying on new path</a></li>
</ul>
<p>Before proceeding to the sections above, please first, make sure you followed the steps in the <a href="tutorials/local-chains/relay-paths/../identifiers.html">Identifiers section</a></p>
<h1><a class="header" href="#create-a-new-path" id="create-a-new-path">Create a new path</a></h1>
<p>Perform client creation, connection and channel handshake to establish a new path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> chains.</p>
<pre><code class="language-shell">hermes create channel ibc-0 ibc-1 --port-a transfer --port-b transfer
</code></pre>
<p>If all the handshakes are performed successfully you should see a message similar to the one below:</p>
<pre><code class="language-json">Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0ns,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}

</code></pre>
<p>Note that for each side, <em>a_side</em> (<strong>ibc-0</strong>) and <em>b_side</em> (<strong>ibc-1</strong>) there are a <strong>client_id</strong>, <strong>connection_id</strong>, <strong>channel_id</strong> and <strong>port_id</strong>. With all these established, you have <a href="tutorials/local-chains/relay-paths/./existing-path.html">a path that you can relay packets</a> </p>
<h1><a class="header" href="#packet-relaying-on-existing-path" id="packet-relaying-on-existing-path">Packet relaying on existing path</a></h1>
<p>Hermes can listen to IBC packet events over a specified path and relay receive packets, acknowledgments and timeouts.</p>
<ol>
<li>
<p>From one terminal start Hermes using the <code>start</code> command and specify the port and a previously established channel:</p>
<pre><code class="language-shell">hermes start ibc-0 ibc-1 -p transfer -c channel-0
</code></pre>
<blockquote>
<p>In this example, the channel identifier on <code>ibc-0</code>is <code>channel-0</code> while the identifier on<code>ibc-1</code> is <code>channel-1</code></p>
</blockquote>
</li>
<li>
<p>In a separate terminal, use the transfer command to send 2 packets to <code>ibc-0</code> chain:</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 2
</code></pre>
<p>You should see a result similar to the one below:</p>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 842,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(1),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 842,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(2),
        },
    ),
]
</code></pre>
</li>
<li>
<p>Use the CLI to send 2 packets to <code>ibc-1</code> chain:</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 9999 1000 -n 2
</code></pre>
<p>You should see a result similar to the one below:</p>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 1,
                height: 963,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(1),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 1,
                height: 963,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(2),
        },
    ),
]
</code></pre>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and that the <code>recv_packet</code>s are sent out.</p>
</li>
<li>
<p>Query the unreceived packets on <code>ibc-0</code> and <code>ibc-1</code> from a different terminal</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
hermes query packet unreceived-acks    ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-packets ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-acks    ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>There should be no unreceived packets and acks:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: []
}
</code></pre>
<blockquote>
<p>It may also show packets that have been sent before the relayer loop was started (Hermes currently does not flush those).</p>
</blockquote>
</li>
</ol>
<h1><a class="header" href="#packet-relaying-on-new-path" id="packet-relaying-on-new-path">Packet relaying on new path</a></h1>
<p>Hermes packet relaying can be done over a newly established path. It performs client creation, connection and channel handshake if a relay path is present in the configuration file.</p>
<ol>
<li>
<p>Specify the path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> by including the following in the configuration file:</p>
<pre><code class="language-toml">[[connections]]
a_chain = 'ibc-1'
b_chain = 'ibc-0'

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'
</code></pre>
</li>
<li>
<p>From one terminal start hermes over this path:</p>
<pre><code class="language-shell">hermes start ibc-0 ibc-1
</code></pre>
<blockquote>
<p>The different modes of operations are currently under heavy development. In this release the fist path specified between two chains is selected.</p>
</blockquote>
<p>Once the path is established the relayer waits listening for IBC packet events.</p>
</li>
<li>
<p>in a separate terminal, use the transfer command to send 2 packets to <code>ibc-0</code> chain:</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>use the CLI to send 2 packets to <code>ibc-1</code> chain:</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and the <code>recv_packet</code> -s are sent out.</p>
</li>
<li>
<p>Query the unreceived packets on <code>ibc-0</code> and <code>ibc-1</code> from a different terminal</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
hermes query packet unreceived-acks    ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-packets ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-acks    ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>There should be no unreceived packets and acks:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: []
}
</code></pre>
<blockquote>
<p>It may also show packets that have been sent before the relayer loop was started (Hermes currently does not flush those).</p>
</blockquote>
</li>
</ol>
<h1><a class="header" href="#concurrent-packet-relaying-on-multiple-paths" id="concurrent-packet-relaying-on-multiple-paths">Concurrent packet relaying on multiple paths</a></h1>
<p>At the moment, the <code>start</code> command relays packets over a single channel.
To relay packets over multiple channels concurrently, one can instead use
the <code>start-multi</code> command.</p>
<blockquote>
<p><strong>WARNING</strong>: Relaying packets concurrently over multiple channels with the
<code>start-multi</code> command is currently <strong>experimental</strong>. Use at your own risk.</p>
</blockquote>
<blockquote>
<p><strong>Caveat</strong>: At the moment, <code>start-multi</code> does not clear pending packets
when starting. It is therefore advised to only use it for channels which
do not have pending packets.</p>
</blockquote>
<ol>
<li>
<p>Paste the following configuration in a file named <strong><code>multi-config.toml</code></strong>:</p>
<pre><code class="language-toml">[global]
strategy = 'naive'
log_level = 'info'

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://127.0.0.1:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://127.0.0.1:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[[chains]]
id = 'ibc-2'
rpc_addr = 'http://127.0.0.1:26457'
grpc_addr = 'http://127.0.0.1:9092'
websocket_addr = 'ws://127.0.0.1:26457/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
fee_denom = 'stake'
fee_amount = 10
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[connections]]
a_chain = 'ibc-0'
b_chain = 'ibc-1'

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'

[[connections]]
a_chain = 'ibc-1'
b_chain = 'ibc-2'

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'
</code></pre>
<p>This configuration three chains <code>ibc-0</code>, <code>ibc-1</code> and <code>ibc-2</code> as well
as two connections: one between <code>ibc-0</code> and <code>ibc-1</code>, and another
between <code>ibc-1</code> and <code>ibc-2</code>, both using the <code>transfer</code> ports.</p>
</li>
<li>
<p>Run the <code>dev-env</code> script with the parameters below to start three chains:</p>
<pre><code class="language-bash">./scripts/dev-env multi-config.toml ibc-0 ibc-1 ibc-2
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the script above prompts you to delete the data folder, answer <strong>'yes'</strong>.</p>
</blockquote>
<p>The script configures and starts three <strong><code>gaiad</code></strong> instances, named <strong><code>ibc-0</code></strong>, and <strong><code>ibc-1</code></strong>, and <strong><code>ibc-2</code></strong>.</p>
</li>
<li>
<p>Create a channel between <code>ibc-0</code> and <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes -c multi-config.toml create channel ibc-0 ibc-1 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0ns,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the channel identifier on both <code>ibc-0</code> and <code>ibc-1</code> is <code>channel-0</code>.</p>
</li>
<li>
<p>Create a channel between <code>ibc-1</code> and <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes -c multi-config.toml create channel ibc-1 ibc-2 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-2&quot;,
                version: 2,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0ns,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the channel identifier on <code>ibc-1</code> is <code>channel-1</code>, and on <code>ibc-2</code> it is <code>channel-0</code>.</p>
</li>
<li>
<p>From a terminal, start Hermes using the <code>start-multi</code> command:</p>
<pre><code class="language-shell">hermes -c multi-config.toml start-multi
</code></pre>
</li>
<li>
<p>In a separate terminal, use the <code>ft-transfer</code> command to send:</p>
<ul>
<li>
<p>two packets from <code>ibc-0</code> to <code>ibc-1</code> from source channel <code>channel-0</code></p>
<pre><code class="language-shell">hermes -c multi-config.toml tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 2
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>two packets from <code>ibc-1</code> to <code>ibc-2</code> from source channel <code>channel-1</code></p>
<pre><code class="language-shell">hermes -c multi-config.toml tx raw ft-transfer ibc-2 ibc-1 transfer channel-1 9999 1000 -n 2
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(4),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and that the <code>recv_packets</code> are sent out.</p>
<pre><code>(...)

INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] result events:
    UpdateClientEv(ev_h:1-3048, 07-tendermint-0(0-3057), )
    WriteAcknowledgementEv(h:1-3048, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    WriteAcknowledgementEv(h:1-3048, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] success

(...)

INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] clearing old packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] received from query_txs []
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] finished clearing pending packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] generate messages from batch with 2 events
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] scheduling op. data with 2 msg(s) for Destination chain (height 1-3049)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] relay op. data to Destination, proofs height 1-3048, (delayed by: 2.154603ms) [try 1/10]
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] prepending Destination client update @ height 1-3049
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] assembled batch of 3 message(s)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] result events:
    UpdateClientEv(ev_h:0-3059, 07-tendermint-0(1-3049), )
    AcknowledgePacketEv(h:0-3059, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    AcknowledgePacketEv(h:0-3059, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] success

(...)
</code></pre>
</li>
<li>
<p>Query the unreceived packets and acknowledgments on <code>ibc-1</code> and <code>ibc-2</code> from a different terminal:</p>
<pre><code class="language-shell">hermes -c multi-config.toml query packet unreceived-packets ibc-0 ibc-1 transfer channel-0
hermes -c multi-config.toml query packet unreceived-acks ibc-1 ibc-0 transfer channel-0
hermes -c multi-config.toml query packet unreceived-packets ibc-2 ibc-1 transfer channel-1
hermes -c multi-config.toml query packet unreceived-acks ibc-1 ibc-2 transfer channel-0
</code></pre>
<p>If everything went well, each of these commands should result in:</p>
<pre><code>Success: []
</code></pre>
</li>
</ol>
<h1><a class="header" href="#connecting-the-chains" id="connecting-the-chains">Connecting the chains</a></h1>
<p>In the rest of this section we will show how to create the clients, establish a connection and a channel between the two chains, and relay packets over the channel. But first, make sure you followed the steps in the <a href="tutorials/local-chains/raw/../start.html">start the local chains</a> and <a href="tutorials/local-chains/raw/../identifiers.html">Identifiers section</a></p>
<h2><a class="header" href="#steps-to-start-relaying-packets-between-the-two-local-chains" id="steps-to-start-relaying-packets-between-the-two-local-chains">Steps to start relaying packets between the two local chains</a></h2>
<p>In order to start relaying packets please follow the steps below:</p>
<ul>
<li><a href="tutorials/local-chains/raw/./client.html">Configure Clients</a></li>
<li><a href="tutorials/local-chains/raw/./connection.html">Connection Handshake</a></li>
<li><a href="tutorials/local-chains/raw/./channel.html">Open the Channel</a></li>
<li><a href="tutorials/local-chains/raw/./packet.html">Relay Packets</a></li>
</ul>
<h1><a class="header" href="#1-configuring-clients" id="1-configuring-clients">1. Configuring clients</a></h1>
<h3><a class="header" href="#11-create-client" id="11-create-client">1.1. <code>create client</code></a></h3>
<p>First you will need to create a client for each chain:</p>
<p>This command submits a transaction to a destination chain (<code>ibc-0</code>) with a request to create a client for a source chain (<code>ibc-1</code>):</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1
</code></pre>
<p>if the command is successful a message similar to the one below will be displayed <code>status:success</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    Success: CreateClient(
        CreateClient(
            Attributes {
                height: Height { revision: 0, height: 43 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 1, height: 32 },
            },
        ),
    )
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Please note the <code>client_id</code> value returned. You will need that for other commands.</p>
</blockquote>
<p>You can also execute a <strong>query</strong> to view the client state on destination chain <code>ibc-0</code> by specifying the <code>client_id</code> value <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-0 07-tendermint-0
</code></pre>
<p>which show a message similar to the one below:</p>
<pre><code class="language-json">Success: ClientState {
    chain_id: ChainId {
        id: &quot;ibc-1&quot;,
        version: 1,
    },
    trust_level: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 1,
        height: 38,
    },
    upgrade_path: [
        &quot;upgrade&quot;,
        &quot;upgradedIBCState&quot;,
    ],
    allow_update_after_expiry: false,
    allow_update_after_misbehaviour: false,
}
</code></pre>
<p>Now let's do the same for <code>ibc-1</code> as the destination chain:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0
</code></pre>
<p>Take note of the <code>client_id</code> allocated for this client. In the examples we assume is <code>07-tendermint-1</code> (this client identity is obtained by creating two clients on ibc-1 for ibc-0).</p>
<p>As before, if the command is successful a message with <code>status:success</code> is displayed:</p>
<pre><code class="language-json">Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 1,
                height: 135,
            },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 0,
                height: 145,
            },
        },
    ),
)
</code></pre>
<h3><a class="header" href="#12-update-client" id="12-update-client">1.2 <code>update-client</code></a></h3>
<p>Client states can be updated by sending an <code>update-client</code> transaction:</p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-shell">hermes tx raw update-client ibc-1 07-tendermint-1
</code></pre>
<h2><a class="header" href="#next-steps-6" id="next-steps-6">Next Steps</a></h2>
<p>In the next section, we'll establish the <a href="tutorials/local-chains/raw/./connection.html">Connection Handshake</a></p>
<h1><a class="header" href="#2-connection-handshake" id="2-connection-handshake">2. Connection Handshake</a></h1>
<h2><a class="header" href="#21-conn-init" id="21-conn-init">2.1 <code>conn-init</code></a></h2>
<p>Initialize a new connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-0</code> on <code>ibc-0</code> in order to use it in the <code>conn-try</code> command below.</p>
<h2><a class="header" href="#22-conn-try" id="22-conn-try">2.2 <code>conn-try</code></a></h2>
<p>Send a connection try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -s connection-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-1</code> on <code>ibc-1</code>. Use in the <code>conn-ack</code> CLI</p>
<h2><a class="header" href="#23-conn-ack" id="23-conn-ack">2.3 <code>conn-ack</code></a></h2>
<p>Send a connection open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1
</code></pre>
<h2><a class="header" href="#24-conn-confirm" id="24-conn-confirm">2.4 <code>conn-confirm</code></a></h2>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0
</code></pre>
<h2><a class="header" href="#25-query-connection" id="25-query-connection">2.5 <code>query connection</code></a></h2>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query connection end ibc-0 connection-0
</code></pre>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1
</code></pre>
<h2><a class="header" href="#next-steps-7" id="next-steps-7">Next Steps</a></h2>
<p>In the next section, we'll <a href="tutorials/local-chains/raw/./channel.html">establish a new channel</a></p>
<h1><a class="header" href="#3-channel-handshake" id="3-channel-handshake">3. Channel Handshake</a></h1>
<h2><a class="header" href="#31-chan-open-init" id="31-chan-open-init">3.1 <code>chan-open-init</code></a></h2>
<p>Initialize a new unordered channel on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer -o UNORDERED
</code></pre>
<h2><a class="header" href="#32-chan-open-try" id="32-chan-open-try">3.2 <code>chan-open-try</code></a></h2>
<p>Send a channel open try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>channel-1</code> on <code>ibc-1</code>. Use in the <code>chan-open-ack</code> CLI</p>
<h2><a class="header" href="#33-chan-open-ack" id="33-chan-open-ack">3.3 <code>chan-open-ack</code></a></h2>
<p>Send a channel open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<h2><a class="header" href="#34-chan-open-confirm" id="34-chan-open-confirm">3.4 <code>chan-open-confirm</code></a></h2>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<h2><a class="header" href="#35-query-channel" id="35-query-channel">3.5 <code>query channel</code></a></h2>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query channel end ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-shell">hermes query channel end ibc-1 transfer channel-1
</code></pre>
<h2><a class="header" href="#next-steps-8" id="next-steps-8">Next Steps</a></h2>
<p>In the next section, we'll start to <a href="tutorials/local-chains/raw/./packet.html">relay packets</a></p>
<h1><a class="header" href="#4-relay-packets" id="4-relay-packets">4. Relay Packets</a></h1>
<h3><a class="header" href="#41-query-balances" id="41-query-balances">4.1 Query balances</a></h3>
<ul>
<li>
<p>balance at ibc-0</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:26657 query bank balances $(gaiad --home data/ibc-0 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
<li>
<p>balance at ibc-1</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:26557 query bank balances $(gaiad --home data/ibc-1 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
</ul>
<blockquote>
<p>Note that the addresses used in the two commands above are configured in <code>dev-env</code>.</p>
</blockquote>
<h3><a class="header" href="#42-packet-relaying" id="42-packet-relaying">4.2 Packet relaying</a></h3>
<p>First, we'll send <code>9999</code> <code>samoleans</code> from <code>ibc-0</code> to <code>ibc-1</code>.</p>
<ul>
<li>
<p>start the transfer of 9999 samoleans from <code>ibc-0</code> to <code>ibc-1</code>. This sends a <code>MsgTransfer</code> in a transaction to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>query packet commitments on <code>ibc-0</code></p>
<pre><code class="language-shell">hermes query packet commitments ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived packets on <code>ibc-1</code></p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>send <code>recv_packet</code> to <code>ibc-1</code></p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived acks on <code>ibc-0</code></p>
<pre><code class="language-shell">hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>send acknowledgement to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw packet-ack ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>send 1 packet with low timeout height offset to ibc-0</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 2 -n 1
</code></pre>
</li>
<li>
<p>send timeout to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
</ul>
<p>Send those samoleans back, from <code>ibc-1</code> to <code>ibc-0</code>.</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 9999 1000 -n 1 -d ibc/49D321B40FCF56B0370E5673CF090389C8E9CD185209FBE1BEE5D94E58E69BDC
hermes tx raw packet-recv ibc-0 ibc-1 transfer channel-1
hermes tx raw packet-ack  ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>The <code>ibc/49D321B40FCF56B0370E5673CF090389C8E9CD185209FBE1BEE5D94E58E69BDC</code> denominator above can be obtained by querying the balance at <code>ibc-1</code> after the transfer from <code>ibc-0</code> to <code>ibc-1</code> is concluded.</p>
<h1><a class="header" href="#commands" id="commands">Commands</a></h1>
<p>The <code>Commands</code> section presents the commands current available in Hermes</p>
<h2><a class="header" href="#sections-2" id="sections-2">Sections</a></h2>
<p><strong><a href="commands/./keys/index.html">Keys</a></strong></p>
<p>Commands to manage keys (private keys) for each chain.</p>
<p><strong><a href="commands/./setup-and-relaying/index.html">Path Setup and Streaming</a></strong></p>
<p>Commands to manage clients, connections, channels and performing packet relaying</p>
<p><strong><a href="commands/./listen/index.html">Listen Mode</a></strong></p>
<p>Commands to listen for IBC events</p>
<p><strong><a href="commands/./upgrade/index.html">Upgrade</a></strong></p>
<p>Commands to perform client upgrade</p>
<p><strong><a href="commands/./misbehaviour/index.html">Monitor</a></strong></p>
<p>Commands to monitor clients and submit evidence of misbehaviour</p>
<p><strong><a href="commands/./queries/index.html">Queries</a></strong></p>
<p>Commands to execute queries on configured chains</p>
<p><strong><a href="commands/./raw/index.html">Raw Transactions</a></strong></p>
<p>Commands to submit individual transactions to configured chains</p>
<h1><a class="header" href="#global-options" id="global-options">Global options</a></h1>
<p>The Hermes accepts global options which affect all commands.</p>
<pre><code class="language-shell">hermes 0.2.0
Informal Systems &lt;hello@informal.systems&gt;
Implementation of `hermes`, an IBC Relayer developed in Rust.

FLAGS:
    -c, --config CONFIG       path to configuration file
    -h, --help                print help message
    -j, --json                enable JSON output
</code></pre>
<p>The flags must be specified right after the <code>hermes</code> command and before any subcommand.</p>
<p><strong>Example</strong></p>
<p>To start the relayer using the configuration file at <code>/home/my_chain.toml</code> and enable JSON output:</p>
<pre><code class="language-shell">hermes -c /home/my_chain.toml --json start ibc-0 ibc-1
</code></pre>
<h2><a class="header" href="#json-output" id="json-output">JSON output</a></h2>
<p>If the <code>--json</code> option is supplied, all relayer commands will output single-line JSON values instead of plain text.</p>
<p>Intermediate log messages will be written to <code>stderr</code>, while the final result will be written to <code>stdout</code>.
This allows processing only the final output using <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.
To process all the output using <code>jq</code>, one can redirect <code>stderr</code> to <code>stdout</code> with <code>hermes --json COMMAND 2&gt;&amp;1 | jq</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1
</code></pre>
<pre><code class="language-json">{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.921&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Using default configuration from: '.hermes/config.toml'&quot;},&quot;target&quot;:&quot;ibc_relayer_cli::commands&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.961&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-1&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.989&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-0&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;result&quot;:{&quot;CreateClient&quot;:{&quot;client_id&quot;:&quot;07-tendermint-1&quot;,&quot;client_type&quot;:&quot;Tendermint&quot;,&quot;consensus_height&quot;:{&quot;revision_height&quot;:10060,&quot;revision_number&quot;:1},&quot;height&quot;:{&quot;revision_height&quot;:10072,&quot;revision_number&quot;:0}}},&quot;status&quot;:&quot;success&quot;}
</code></pre>
<p>The first three lines are printed to <code>stderr</code>, while the last line with a <code>&quot;result&quot;</code> key is printed to <code>stdout</code>.</p>
<p><strong>Example</strong></p>
<p>To improve the readability, pipe all of the output to <code>jq</code>:</p>
<pre><code>hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1 2&gt;&amp;1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.060&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;Using default configuration from: '.hermes/config.toml'&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer_cli::commands&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.082&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-1&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.088&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-0&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;result&quot;: {
    &quot;CreateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-5&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 10364,
        &quot;revision_number&quot;: 1
      },
      &quot;height&quot;: {
        &quot;revision_height&quot;: 10375,
        &quot;revision_number&quot;: 0
      }
    }
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<p><strong>Example</strong></p>
<p>To extract the identifer of the newly created client above:</p>
<pre><code>hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1 | jq '.result.CreateClient.client_id'
</code></pre>
<pre><code>&quot;07-tendermint-2&quot;
</code></pre>
<h1><a class="header" href="#adding-keys-to-the-relayer" id="adding-keys-to-the-relayer">Adding Keys to the Relayer</a></h1>
<blockquote>
<p><strong>WARNING</strong>: Currently the relayer does NOT support a <code>keyring</code> store to securely
store the private key file. The key file will be stored on the local file system
in the user <strong>$HOME</strong> folder under <code>$HOME/.rrly</code></p>
</blockquote>
<blockquote>
<p><strong>BREAKING</strong>: As of Hermes v0.2.0, the format of the keys stored on disk has changed, and
keys which had been previously configured must now be re-imported using either the <code>keys add</code>
or the <code>keys restore</code> commands.</p>
</blockquote>
<hr />
<p>Using the <code>keys</code> command you can add and list keys. </p>
<h4><a class="header" href="#show-usage" id="show-usage">Show usage</a></h4>
<p>To see the available sub-commands for the <code>keys</code> command run:</p>
<pre><code class="language-shell">hermes help keys
</code></pre>
<p>Currently there are two sub-commands supported <code>add</code> and <code>list</code>:</p>
<pre><code class="language-shell">USAGE:
    hermes-cli keys &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Manage keys in the relayer for each chain

SUBCOMMANDS:
    help       Get usage information
    add        adds a key to a configured chain
    list       list keys configured on a chain
</code></pre>
<h3><a class="header" href="#key-seed-file-private-key" id="key-seed-file-private-key">Key Seed file (Private Key)</a></h3>
<p>In order to execute the command below you need a private key file (JSON). The relayer uses the private key file to sign the transactions submitted to the chain.</p>
<p>The private key file can be obtained by using the <code>keys add</code> on a Cosmos chain, for example for a <code>gaia</code> chain the command is:</p>
<pre><code class="language-shell">gaiad keys add ...
</code></pre>
<p>The command outputs a JSON similar to the one below. You can save this file (e.g. <code>key_seed.json</code>) and use it to add to the relayer</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;user&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<h3><a class="header" href="#adding-keys" id="adding-keys">Adding Keys</a></h3>
<h4><a class="header" href="#add-a-private-key-to-a-chain-from-a-key-file" id="add-a-private-key-to-a-chain-from-a-key-file">Add a private key to a chain from a key file</a></h4>
<pre><code class="language-shell">USAGE:
    hermes keys add &lt;OPTIONS&gt;

DESCRIPTION:
    Adds a key to a configured chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain

FLAGS:
    -f, --file FILE           the path to the key file (conflicts with --mnemonic)
</code></pre>
<p>To add a private key file to a chain:</p>
<pre><code class="language-shell">hermes -c config keys add [CHAIN_ID] -f [PRIVATE_KEY_FILE]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Added key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<h4><a class="header" href="#restore-a-private-key-to-a-chain-from-a-mnemonic" id="restore-a-private-key-to-a-chain-from-a-mnemonic">Restore a private key to a chain from a mnemonic</a></h4>
<pre><code class="language-shell">USAGE:
    hermes keys restore &lt;OPTIONS&gt;

DESCRIPTION:
    restore a key to a configured chain using a mnemonic

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain

FLAGS:
    -n, --name NAME           key name
    -m, --mnemonic MNEMONIC   mnemonic to restore the key from
</code></pre>
<p>To restore a key from its mnemonic:</p>
<pre><code class="language-shell">hermes -c config keys restore [CHAIN_ID] -m &quot;[MNEMONIC]&quot;
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Restore key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<h3><a class="header" href="#list-keys" id="list-keys">List keys</a></h3>
<p>In order to list the private keys added to chains use the <code>keys list</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys list &lt;OPTIONS&gt;

DESCRIPTION:
    List keys configured on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain
</code></pre>
<h4><a class="header" href="#listing-the-private-key-that-was-added-to-a-chain" id="listing-the-private-key-that-was-added-to-a-chain">Listing the private key that was added to a chain</a></h4>
<p>To list the private key file that was added to a chain:</p>
<pre><code class="language-shell">hermes -c config keys list [CHAIN_ID]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">[CHAIN_ID] -&gt; [KEY_NAME] ([ADDRESS])
</code></pre>
<h1><a class="header" href="#path-setup-and-relay-commands" id="path-setup-and-relay-commands">Path Setup and Relay Commands</a></h1>
<p>This section describes a number of commands that can be used to manage clients, connections, channels and relay over new or existing  paths.</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create client</code></td><td><a href="commands/setup-and-relaying/./clients.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update client</code></td><td><a href="commands/setup-and-relaying/./clients.html#md-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>create connection</code></td><td><a href="commands/setup-and-relaying/./connections.html#establish-connection">Establish a connection using existing or new clients</a></td></tr>
<tr><td><code>create channel</code></td><td><a href="commands/setup-and-relaying/./channels.html#establish-channel">Establish a channel using existing or new connection</a></td></tr>
<tr><td><code>start</code></td><td><a href="commands/setup-and-relaying/./packets.html#start">Relay packets over a new or exsiting channel</a></td></tr>
</tbody></table>
<h2><a class="header" href="#create" id="create">Create</a></h2>
<p>Use the <code>create</code> commands to create a new clients, connections and channels.</p>
<pre><code class="language-shell">USAGE:
    hermes create &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Create objects (client, connection, or channel) on chains

SUBCOMMANDS:
    help       Get usage information
    client     Create a new IBC client
    connection Create a new connection between two chains
    channel    Create a new channel between two chains
</code></pre>
<h2><a class="header" href="#relay" id="relay">Relay</a></h2>
<p>Use the <code>start</code> commands to start relaying packets over one path.</p>
<pre><code class="language-shell">USAGE:
    hermes start &lt;OPTIONS&gt;

DESCRIPTION:
    Start the relayer

POSITIONAL ARGUMENTS:
    src_chain_id              identifier of the source chain
    dst_chain_id              identifier of the destination chain

FLAGS:
    -p, --src-port-id SRC-PORT-ID
    -c, --src-channel-id SRC-CHANNEL-ID
</code></pre>
<h1><a class="header" href="#client" id="client">Client</a></h1>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="commands/setup-and-relaying/clients.html#create-client">Create Client</a></li>
<li><a href="commands/setup-and-relaying/clients.html#update-client">Update Client</a></li>
</ul>
<h2><a class="header" href="#create-client" id="create-client">Create Client</a></h2>
<p>Use the <code>create client</code> command to create a new client.</p>
<pre><code class="language-shell">USAGE:
    hermes create client &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client of <code>ibc-1</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes create client ibc-0 ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height { revision: 0, height: 264 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 253 },
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>A new client is created with identifier <code>07-tendermint-1</code></p>
<h2><a class="header" href="#update-client" id="update-client">Update Client</a></h2>
<p>Use the <code>update client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes update client &lt;OPTIONS&gt;

DESCRIPTION:
    Update an IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be updated on destination chain

FLAGS:
    -h, --target-height TARGET-HEIGHT
    -t, --trusted-height TRUSTED-HEIGHT
</code></pre>
<p><strong>Update client with latest header</strong></p>
<p>the client on <code>ibc-0</code> with latest header of <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes update client ibc-0 07-tendermint-9
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 303 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 293 },
        },
        header: Some(
            Tendermint(...),
        ),
    },
)
<span class="boring">}
</span></code></pre></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-293</code>.</p>
<p><strong>Update a client to a specific target height</strong></p>
<pre><code class="language-shell">hermes update client ibc-0 07-tendermint-1 --target-height 320 --trusted-height 293
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 555 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 320 },
        },
        header: Some(
            Tendermint(...),
        ),
    },
)
<span class="boring">}
</span></code></pre></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-320</code>, as specified.</p>
<h1><a class="header" href="#connection" id="connection">Connection</a></h1>
<h2><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="commands/setup-and-relaying/connections.html#establish-connection">Establish Connection</a></li>
<li><a href="commands/setup-and-relaying/connections.html#non-zero-delay-connection">Non-zero Delay Connection</a></li>
</ul>
<h2><a class="header" href="#establish-connection" id="establish-connection">Establish Connection</a></h2>
<p>Use the <code>create connection</code> command to create a new connection.</p>
<pre><code class="language-shell">USAGE:
    hermes create connection &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new connection between two chains

POSITIONAL ARGUMENTS:
    chain_a_id                identifier of the side `a` chain for the new connection
    chain_b_id                identifier of the side `b` chain for the new connection

FLAGS:
    --client-a CLIENT-A       identifier of client hosted on chain `a`; default: None (creates a new client)
    --client-b CLIENT-B       identifier of client hosted on chain `b`; default: None (creates a new client)

</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes create connection ibc-0 ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 4069 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 4081 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0ns,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}]

Success: Connection {
    delay_period: 0ns,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#non-zero-delay-connection" id="non-zero-delay-connection">Non-zero Delay Connection</a></h2>
<p>A connection can be created with a delay period parameter. This parameter specifies a period of time that must elpase after a successful client state update and before a packet with proofs using its commitment root can pe processed on chain. For more information see <a href="commands/setup-and-relaying/./packets.html#packet-delay">how packet delay works</a> and  the <a href="https://github.com/cosmos/ibc/tree/master/spec/core/ics-003-connection-semantics">connection delay specification</a>.</p>
<h1><a class="header" href="#channel" id="channel">Channel</a></h1>
<h2><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="commands/setup-and-relaying/channels.html#establish-channel">Establish Channel</a></li>
<li><a href="commands/setup-and-relaying/channels.html#examples">Examples</a>
<ul>
<li><a href="commands/setup-and-relaying/channels.html#new-channel-over-a-new-connection">New channel over a new connection</a></li>
<li><a href="commands/setup-and-relaying/channels.html#new-channel-over-an-existing-connection">New channel over an existing connection</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#establish-channel" id="establish-channel">Establish Channel</a></h2>
<p>Use the <code>create channel</code> command to establish a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes create channel &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new channel between two chains

POSITIONAL ARGUMENTS:
    chain_a_id                identifier of the side `a` chain for the new channel
    chain_b_id                identifier of the side `b` chain for the new channel (optional)

FLAGS:
    -c, --connection-a CONNECTION-A
    --port-a PORT-A           identifier of the side `a` port for the new channel
    --port-b PORT-B           identifier of the side `b` port for the new channel
    -o, --order ORDER         the channel ordering, valid options 'unordered' (default) and 'ordered'
    -v, --version VERSION     the version for the new channel
</code></pre>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#new-channel-over-a-new-connection" id="new-channel-over-a-new-connection">New channel over a new connection</a></h3>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over a new connection, using
port name <code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel ibc-0 ibc-1 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 66 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 64 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 76 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 68 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0ns,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
}]

🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 78 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 70 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 81 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel
    OpenConfirm
        Attributes {
            height: Height { revision: 1, height: 73 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0ns,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0ns,
}
<span class="boring">}
</span></code></pre></pre>
<p>A new channel with identifier <code>channel-0</code> on both sides has been established on
a new connection with identifier <code>connection-0</code> on both sides.</p>
<h3><a class="header" href="#new-channel-over-an-existing-connection" id="new-channel-over-an-existing-connection">New channel over an existing connection</a></h3>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over an existing connection,
specifically the one we just created in the example above, with port name <code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel ibc-0 --connection-a connection-0 --port-a transfer --port-b transfer -o unordered
</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given connection on <code>ibc-0</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 126 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 137 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0ns,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0ns,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#packet-relaying" id="packet-relaying">Packet Relaying</a></h1>
<h2><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="commands/setup-and-relaying/packets.html#start">Start</a></li>
<li><a href="commands/setup-and-relaying/packets.html#start-with-new-channel">Start with New Channel</a></li>
<li><a href="commands/setup-and-relaying/packets.html#start-on-existing-channel">Start on Existing Channel</a></li>
<li><a href="commands/setup-and-relaying/packets.html#packet-streaming">Packet Streaming</a></li>
<li><a href="commands/setup-and-relaying/packets.html#packet-delay">Packet Delay</a></li>
</ul>
<h2><a class="header" href="#start" id="start">Start</a></h2>
<p>The <code>start</code> command can be used to send packet transactions triggered by IBC packet events that occur for a given channel. This is also referred to packet streaming.
A new channel can be established or an existing one can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes start &lt;OPTIONS&gt;

DESCRIPTION:
    start the relayer (currently this refers to the v0 relayer)

POSITIONAL ARGUMENTS:
    src_chain_id              identifier of the source chain
    dst_chain_id              identifier of the destination chain

FLAGS:
    -p, --src-port-id SRC-PORT-ID
    -c, --src-channel-id SRC-CHANNEL-ID
</code></pre>
<h2><a class="header" href="#start-with-new-channel" id="start-with-new-channel">Start with New Channel</a></h2>
<p>Use the <code>start</code> command without flags to create new clients on <code>source</code> and <code>destination</code> chains, and new connection and new channel between the two chains.</p>
<blockquote>
<p>Reusing existing clients or connection is not possible with the current version. The port used by the channel is obtained from and must be specified in the configuration file.</p>
</blockquote>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes start ibc-0 ibc-1
</code></pre>
<p>The relayer creates a new client on each chain and then established a new connection and a new channel using that connection. After that is enters a listen loop acting on packet events that occur on that channel.</p>
<h2><a class="header" href="#start-on-existing-channel" id="start-on-existing-channel">Start on Existing Channel</a></h2>
<p>Use the <code>start</code> command and specify the source port and channel identifier of a channel that is already created and in open state on both chains.</p>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes start ibc-0 ibc-1 -p transfer -c channel-0
</code></pre>
<blockquote>
<p>Finishing uncompleted handshakes can only be achieved using the <code>tx raw</code> CLIs.</p>
</blockquote>
<h2><a class="header" href="#packet-streaming" id="packet-streaming">Packet Streaming</a></h2>
<p>After the relayer is started using the <code>start</code> command, it listens to IBC packet events for the channel. Assuming the events are coming from a <code>source</code> chain, the relayer builds packets based on these events, packets that are then sent either to the <code>source</code> chain or the counterparty (<code>destination</code>) chain. </p>
<p>Current events and actions are:</p>
<ul>
<li><code>send_packet</code>: the relayer builds a packet message with the <code>packet</code> obtained from the event and any required proofs obtained from the counterparty of the chain where the message is sent. The concrete packet is:
<ul>
<li><code>MsgRecvPacket</code>, sent to <code>destination</code> chain if the channel is in open state on the <code>destination</code> chain, and a timeout has not occurred,</li>
<li><code>MsgTimeout</code>, sent to the <code>source</code> chain if the channel is in open state on the <code>destination</code> chain, but a timeout has occurred.</li>
<li><code>MsgTimeoutOnClose</code>, sent to the <code>source</code> chain if the channel is in closed state on the <code>destination</code> chain.</li>
</ul>
</li>
<li><code>write_acknowledgement</code>: the relayer builds a <code>MsgAcknowledgement</code> packet that is sent to the <code>destination</code> chain.</li>
</ul>
<h2><a class="header" href="#packet-delay" id="packet-delay">Packet Delay</a></h2>
<p>If the relay path is using a non-zero delay connection, then <code>hermes</code> will delay all packet transactions. The delay is
relative to the submission time for the client update at the height required by the packet proof.
The delay is used to prevent light client attacks and ensures that misbehavior detection finalizes before the transaction is submitted.
For more information on the misbehavior detector see <a href="commands/setup-and-relaying/../misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">the misbehaviour section</a>.</p>
<h1><a class="header" href="#relayer-listen-mode" id="relayer-listen-mode">Relayer Listen Mode</a></h1>
<p>The relayer can be started in <code>listen</code> mode to display the events emitted by a given chain. <code>NewBlock</code> and <code>Tx</code> IBC events are shown.</p>
<pre><code class="language-shell">USAGE:
    hermes listen &lt;OPTIONS&gt;

DESCRIPTION:
    Listen to and display IBC events emitted by a chain

POSITIONAL ARGUMENTS:
    chain_id                  Identifier of the chain to listen for events from

FLAGS:
    -e, --event EVENT         Add an event type to listen for, can be repeated. Listen for all events by default (available: Tx, NewBlock)
</code></pre>
<p><strong>Example</strong></p>
<p>Start the relayer in listen mode for all <code>ibc-0</code> events and observe the output:</p>
<pre><code class="language-shell">hermes listen ibc-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10914),
    events: [
        NewBlock(
            NewBlock {
                height: block::Height(10914),
            },
        ),
    ],
}
EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10915),
    events: [
        OpenInitConnection(
            OpenInit(
                Attributes {
                    height: block::Height(10915),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: None,
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10919),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10919),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10907,
                    },
                },
            ),
        ),
    ],
}

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10924),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10924),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10912,
                    },
                },
            ),
        ),
        OpenAckConnection(
            OpenAck(
                Attributes {
                    height: block::Height(10924),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: Some(
                        ConnectionId(
                            &quot;connection-5&quot;,
                        ),
                    ),
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#filter-events" id="filter-events">Filter events</a></h2>
<p>The <code>listen</code> command accepts an <code>--event</code> flag to specify which event types to listen for.</p>
<p>At the moment, two event types are available:</p>
<ul>
<li><code>NewBlock</code> </li>
<li><code>Tx</code></li>
</ul>
<p>The <code>--event</code> flag can be repeated to specify more than one event type.</p>
<ul>
<li>To listen for only <code>NewBlock</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --event NewBlock</code></li>
<li>To listen for only <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --event Tx</code></li>
<li>To listen for both <code>NewBlock</code> and <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --e NewBlock --event Tx</code></li>
</ul>
<p>If the <code>--event</code> flag is omitted, the relayer will subscribe to all event types.</p>
<h1><a class="header" href="#client-upgrade" id="client-upgrade">Client Upgrade</a></h1>
<h2><a class="header" href="#client-upgrade-command" id="client-upgrade-command">Client Upgrade Command</a></h2>
<p>Use the <code>upgrade client</code> command to upgrade a client after a chain upgrade.</p>
<pre><code class="language-shell">USAGE:
    hermes upgrade client &lt;OPTIONS&gt;

DESCRIPTION:
    Upgrade an IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be upgraded on destination chain
</code></pre>
<p><strong>Example</strong></p>
<p>Here is <a href="commands/upgrade/./test.html">an example</a> of a chain upgrade proposal submission and client upgrade.</p>
<h1><a class="header" href="#testing-client-upgrade" id="testing-client-upgrade">Testing Client Upgrade</a></h1>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<ul>
<li>gaiad <code>(v4.2.*)</code>, for example:</li>
</ul>
<pre><code class="language-shell">$ gaiad version --log_level error --long | head -n4
name: gaia
server_name: gaiad
version: v4.2.0
commit: 535be14a8bdbfeb0d950914b5baa2dc72c6b081c
</code></pre>
<h2><a class="header" href="#testing-procedure" id="testing-procedure">Testing procedure</a></h2>
<ol>
<li>
<p>Start two gaia instances and initialize hermes:</p>
<pre><code class="language-shell">$ ./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1
</code></pre>
<p>The <code>one-chain</code> script is invoked for each chain and modifies the <code>genesis.json</code> file to use a short window for governance proposals (<code>200s</code> for <code>max_deposit_period</code> and <code>voting_period</code>). Therefore, an upgrade proposal can be submitted, voted on and accepted within a short time.</p>
</li>
<li>
<p>Create one client on <code>ibc-1</code> for <code>ibc-0</code>:</p>
<pre><code class="language-shell">$ hermes create client ibc-1 ibc-0

Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height { revision: 1, height: 9 },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height { revision: 0, height: 18 },
       },
   ),
)
</code></pre>
</li>
<li>
<p>Create and submit an upgrade plan for chain <code>ibc-0</code>:</p>
<p>Use the hermes test command to make an upgrade proposal. In the example below a software upgrade proposal is made for <code>ibc-0</code>, for the height <code>300</code> blocks from latest height. <code>10000000stake</code> is deposited.
The proposal includes the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code> that was created in the previous step. In addition, the <code>unbonding_period</code> of the client is set to some new value (<code>400h</code>)</p>
<pre><code class="language-shell">$ hermes tx raw upgrade-chain ibc-0 ibc-1 07-tendermint-0 10000000 300
Success: []
</code></pre>
<p>Note that the height offset should be picked such that the proposal plan height is reached after the <code>200s</code> voting period.</p>
</li>
<li>
<p>Verify that the proposal was accepted:</p>
<p>Query the upgrade plan to check that it was submitted correctly. Note the <code>height</code> at which the proposal will take effect (chain halts). Also <code>status: PROPOSAL_STATUS_VOTING_PERIOD</code>.</p>
<pre><code class="language-shell">gaiad query gov proposal 1 --home data/ibc-0/
</code></pre>
<pre><code>content:
  '@type': /cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
  description: upgrade the chain software and unbonding period
  plan:
    height: &quot;332&quot;
    info: upgrade the chain software and unbonding period
    name: test
    time: &quot;0001-01-01T00:00:00Z&quot;
    upgraded_client_state:
      '@type': /ibc.lightclients.tendermint.v1.ClientState
      allow_update_after_expiry: false
      allow_update_after_misbehaviour: false
      chain_id: ibc-0
      frozen_height:
        revision_height: &quot;0&quot;
        revision_number: &quot;0&quot;
      latest_height:
        revision_height: &quot;333&quot;
        revision_number: &quot;0&quot;
      max_clock_drift: 0s
      proof_specs:
      - inner_spec:
          child_order:
          - 0
          - 1
          child_size: 33
          empty_child: null
          hash: SHA256
          max_prefix_length: 12
          min_prefix_length: 4
        leaf_spec:
          hash: SHA256
          length: VAR_PROTO
          prefix: AA==
          prehash_key: NO_HASH
          prehash_value: SHA256
        max_depth: 0
        min_depth: 0
      - inner_spec:
          child_order:
          - 0
          - 1
          child_size: 32
          empty_child: null
          hash: SHA256
          max_prefix_length: 1
          min_prefix_length: 1
        leaf_spec:
          hash: SHA256
          length: VAR_PROTO
          prefix: AA==
          prehash_key: NO_HASH
          prehash_value: SHA256
        max_depth: 0
        min_depth: 0
      trust_level:
        denominator: &quot;0&quot;
        numerator: &quot;0&quot;
      trusting_period: 0s
      unbonding_period: 1440000s
      upgrade_path:
      - upgrade
      - upgradedIBCState
  title: upgrade_ibc_clients
deposit_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
final_tally_result:
  abstain: &quot;0&quot;
  &quot;no&quot;: &quot;0&quot;
  no_with_veto: &quot;0&quot;
  &quot;yes&quot;: &quot;0&quot;
proposal_id: &quot;1&quot;
status: PROPOSAL_STATUS_VOTING_PERIOD
submit_time: &quot;2021-04-12T16:30:17.187389Z&quot;
total_deposit:
- amount: &quot;10000000&quot;
  denom: stake
voting_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
voting_start_time: &quot;2021-04-12T16:30:17.187389Z&quot;
</code></pre>
</li>
<li>
<p>Vote on the proposal</p>
<p>The parameter <code>1</code> should match the <code>proposal_id:</code> from the upgrade proposal submitted at step 3.
This command must be issued while the proposal status is <code>PROPOSAL_STATUS_VOTING_PERIOD</code>. Confirm transaction when prompted.</p>
<pre><code class="language-shell">$ gaiad tx gov vote 1 yes --home data/ibc-0/data/ --keyring-backend test --keyring-dir data/ibc-0/ --chain-id ibc-0 --from validator
confirm transaction before signing and broadcasting [y/N]: y

{&quot;height&quot;:&quot;85&quot;,&quot;txhash&quot;:&quot;AC24D80B1BFE0832769DECFDD3B3DF999A363D5E4390B0B673344FFDED9150B2&quot;,&quot;codespace&quot;:&quot;&quot;,&quot;code&quot;:0,&quot;data&quot;:&quot;0A060A04766F7465&quot;,&quot;raw_log&quot;:&quot;[{\&quot;events\&quot;:[{\&quot;type\&quot;:\&quot;message\&quot;,\&quot;attributes\&quot;:[{\&quot;key\&quot;:\&quot;action\&quot;,\&quot;value\&quot;:\&quot;vote\&quot;},{\&quot;key\&quot;:\&quot;module\&quot;,\&quot;value\&quot;:\&quot;governance\&quot;},{\&quot;key\&quot;:\&quot;sender\&quot;,\&quot;value\&quot;:\&quot;cosmos1srfzw0jkyyn7wf0ps4zy0tuvdaclfj2ufgp6w3\&quot;}]},{\&quot;type\&quot;:\&quot;proposal_vote\&quot;,\&quot;attributes\&quot;:[{\&quot;key\&quot;:\&quot;option\&quot;,\&quot;value\&quot;:\&quot;VOTE_OPTION_YES\&quot;},{\&quot;key\&quot;:\&quot;proposal_id\&quot;,\&quot;value\&quot;:\&quot;1\&quot;}]}]}]&quot;,&quot;logs&quot;:[{&quot;msg_index&quot;:0,&quot;log&quot;:&quot;&quot;,&quot;events&quot;:[{&quot;type&quot;:&quot;message&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;vote&quot;},{&quot;key&quot;:&quot;module&quot;,&quot;value&quot;:&quot;governance&quot;},{&quot;key&quot;:&quot;sender&quot;,&quot;value&quot;:&quot;cosmos1srfzw0jkyyn7wf0ps4zy0tuvdaclfj2ufgp6w3&quot;}]},{&quot;type&quot;:&quot;proposal_vote&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;option&quot;,&quot;value&quot;:&quot;VOTE_OPTION_YES&quot;},{&quot;key&quot;:&quot;proposal_id&quot;,&quot;value&quot;:&quot;1&quot;}]}]}],&quot;info&quot;:&quot;&quot;,&quot;gas_wanted&quot;:&quot;200000&quot;,&quot;gas_used&quot;:&quot;43716&quot;,&quot;tx&quot;:null,&quot;timestamp&quot;:&quot;&quot;}
</code></pre>
</li>
<li>
<p>Wait approximately 200 seconds until the proposal changes status to <code>PROPOSAL_STATUS_PASSED</code>.
Note the <code>final tally_result</code> that includes the vote submitted in the previous step.</p>
</li>
</ol>
<pre><code>```shell
gaiad query gov proposal 1 --home data/ibc-0/
```

```
content:
  '@type': /cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
  description: upgrade the chain software and unbonding period
...
final_tally_result:
  abstain: &quot;0&quot;
  &quot;no&quot;: &quot;0&quot;
  no_with_veto: &quot;0&quot;
  &quot;yes&quot;: &quot;100000000000&quot;
proposal_id: &quot;1&quot;
status: PROPOSAL_STATUS_PASSED
submit_time: &quot;2021-04-12T16:30:17.187389Z&quot;
total_deposit:
- amount: &quot;10000000&quot;
  denom: stake
voting_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
voting_start_time: &quot;2021-04-12T16:30:17.187389Z&quot;
```
</code></pre>
<ol start="6">
<li>
<p>Test the <code>upgrade client</code> CLI</p>
<p>The following command performs the upgrade for client <code>07-tendermint-0</code>. It outputs two events, one for the updated client state,
and another for the upgraded state.</p>
<pre><code class="language-shell">$ hermes upgrade client ibc-1 07-tendermint-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height { revision: 1, height: 438 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 0, height: 440 },
            },
            header: Some(
                Tendermint(..)
            ),
        },
    ),
    UpgradeClient(
        UpgradeClient(
            Attributes {
                height: Height { revision: 1, height: 438 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 0, height: 441 },
            },
        ),
    ),
]
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<h1><a class="header" href="#misbehaviour" id="misbehaviour">Misbehaviour</a></h1>
<h2><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="commands/misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></li>
</ul>
<h2><a class="header" href="#monitoring-misbehaviour-and-evidence-submission" id="monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></h2>
<p>Use the <code>mishbehaviour</code> command to monitor the updates for a given client, detect certain types of misbehaviour and
submit evidence to the chain. If the evidence passes the on-chain validation, the client is frozen. Further packets
cannot be relayed using the frozen client.</p>
<pre><code class="language-shell">USAGE:
    hermes misbehaviour &lt;OPTIONS&gt;

DESCRIPTION:
    Listen to client update IBC events and handles misbehaviour

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain where client updates are monitored for misbehaviour
    client_id                 identifier of the client to be monitored for misbehaviour
</code></pre>
<p>The misbehaviour monitor starts by analyzing all headers used in prior client updates.
Once finished it registers for update client events and checks any new headers for misbehaviour.
If it detects evidence of misbehaviour, it submits a transaction with the evidence to the chain.
If the chain validates the transaction then the monitor exits.</p>
<blockquote>
<p>This is an experimental feature.</p>
</blockquote>
<p>The following types of misbehaviour are handled:</p>
<ol>
<li>
<p><strong>Fork</strong></p>
<p>Assumes at least one consensus state before the fork point exists.
Let existing consensus states on chain B be: <code>[Sn,.., Sf, Sf-1, S0]</code> with <code>Sf-1</code> being
the most recent state before the fork.
Chain A is queried for a header <code>Hf'</code> at <code>Sf.height</code> and if it is different than the <code>Hf</code>
in the event for the client update (the one that has generated <code>Sf</code> on chain), then the two
headers are included in the evidence and submitted.
Note that in this case the headers are different but have the same height.</p>
</li>
<li>
<p><strong>BFT time violation for an unavailable header</strong></p>
<p>Some header with a height that is higher than the latest
height on chain <code>A</code> has been accepted and a consensus state was created on <code>B</code>. Note that this implies
that the timestamp of this header must be within the <code>clock_drift</code> of the client.
Assume the client on <code>B</code> has been updated with <code>h2</code>(not present on/ produced by chain <code>A</code>)
and it has a timestamp of <code>t2</code> that is at most <code>clock_drift</code> in the future.
Then the latest header from <code>A</code> is fetched, let it be <code>h1</code>, with a timestamp of <code>t1</code>.
If <code>t1 &gt;= t2</code> then evidence of misbehavior is submitted to A.</p>
</li>
</ol>
<p><strong>Example</strong></p>
<p>The <code>hermes misbehaviour</code> outputs an error message displaying <code>MISBEHAVIOUR DETECTED</code>:</p>
<pre><code class="language-shell">hermes misbehaviour ibc-0 07-tendermint-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Apr 13 20:04:03.347  INFO ibc_relayer::foreign_client: checking misbehaviour for consensus state heights [Height { revision: 1, height: 195 }, Height { revision: 1, height: 85 }, Height { revision: 1, height: 28 }]
Apr 13 20:04:04.425 ERROR ibc_relayer::foreign_client: MISBEHAVIOUR DETECTED ClientId(&quot;07-tendermint-0&quot;) h1: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 } h2: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 }, sending evidence
Apr 13 20:04:05.070  INFO ibc_relayer_cli::commands::misbehaviour: evidence submission result [ClientMisbehaviour(ClientMisbehaviour(Attributes { height: Height { revision: 0, height: 1521 }, client_id: ClientId(&quot;07-tendermint-0&quot;), client_type: Tendermint, consensus_height: Height { revision: 1, height: 195 } }))]

Success: Some(
    ClientMisbehaviour(
        ClientMisbehaviour(
            Attributes {
                height: Height {
                    revision: 0,
                    height: 1521,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 195,
                },
            },
        ),
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>Querying client state from this point will show the client is in frozen state, with <code>frozen_height</code> indicating the height at which the client was frozen:</p>
<pre><code class="language-shell">hermes query client state ibc-0 07-tendermint-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;allow_update_after_expiry&quot;: false,
    &quot;allow_update_after_misbehaviour&quot;: false,
    &quot;chain_id&quot;: &quot;ibc-1&quot;,
    &quot;frozen_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;latest_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;max_clock_drift&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 3
    },
    &quot;trust_level&quot;: {
      &quot;denominator&quot;: &quot;3&quot;,
      &quot;numerator&quot;: &quot;1&quot;
    },
    &quot;trusting_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1209600
    },
    &quot;unbonding_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1814400
    },
    &quot;upgrade_path&quot;: [
      &quot;upgrade&quot;,
      &quot;upgradedIBCState&quot;
    ]
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<h1><a class="header" href="#queries" id="queries">Queries</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><a href="commands/queries/./client.html">Query information about clients</a></td></tr>
<tr><td><code>clients</code></td><td><a href="commands/queries/./client.html">Query all clients</a></td></tr>
<tr><td><code>connection</code></td><td><a href="commands/queries/./connection.html">Query information about connections</a></td></tr>
<tr><td><code>connections</code></td><td><a href="commands/queries/./connection.html">Query the identifiers of all connections on a chain</a></td></tr>
<tr><td><code>channel</code></td><td><a href="commands/queries/./channel.html">Query information about channels</a></td></tr>
<tr><td><code>channels</code></td><td><a href="commands/queries/./channel.html">Query the identifiers of all channels on a given chain</a></td></tr>
<tr><td><code>packet</code></td><td><a href="commands/queries/./packet.html">Query information about packets</a></td></tr>
</tbody></table>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<pre><code>USAGE:
    hermes query &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query objects from the chain

SUBCOMMANDS:
    client         Query information about clients
    clients        Query clients
    connection     Query information about connections
    connections    Query the identifiers of all connections on a chain
    channel        Query information about channels
    channels       Query the identifiers of all channels on a given chain
    packet         Query information about packets
</code></pre>
<h1><a class="header" href="#table-of-contents-5" id="table-of-contents-5">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/client.html#query-clients">Query Clients</a></li>
<li><a href="commands/queries/client.html#query-client-data">Query Client Data</a>
<ul>
<li><a href="commands/queries/client.html#query-the-client-state">Query the client state</a></li>
<li><a href="commands/queries/client.html#query-the-client-consensus-state">Query the client consensus state</a></li>
<li><a href="commands/queries/client.html#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></li>
<li><a href="commands/queries/client.html#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-clients" id="query-clients">Query Clients</a></h1>
<p>Use the <code>query clients</code> command to query the identifiers of all clients on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query clients &lt;OPTIONS&gt;

DESCRIPTION:
    Query clients

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all clients on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query clients ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    ClientId(&quot;07-tendermint-0&quot;),
    ClientId(&quot;07-tendermint-1&quot;),
]
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#query-client-data" id="query-client-data">Query Client Data</a></h1>
<p>Use the <code>query client</code> command to query the information about a specific client.</p>
<pre><code class="language-shell">USAGE:
    hermes query client &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about clients

SUBCOMMANDS:
    state      query client full state
    consensus  query client consensus
    connections query client connections
</code></pre>
<h2><a class="header" href="#query-the-client-state" id="query-the-client-state">Query the client state</a></h2>
<p>Use the <code>query client state</code> command to query the client state of a client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client state &lt;OPTIONS&gt;

DESCRIPTION:
    Query client full state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -h, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-1 07-tendermint-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: ClientState {
    chain_id: ChainId {
        id: &quot;ibc-2&quot;,
        version: 2,
    },
    trust_level: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 2,
        height: 3069,
    },
    upgrade_path: [
        &quot;upgrade&quot;,
        &quot;upgradedIBCState&quot;,
    ],
    allow_update_after_expiry: false,
    allow_update_after_misbehaviour: false,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#query-the-client-consensus-state" id="query-the-client-consensus-state">Query the client consensus state</a></h2>
<p>Use the <code>query client consensus</code> command to query the consensus states of a given client, or the state at a specified height:</p>
<pre><code class="language-shell">USAGE:
    hermes query client consensus &lt;OPTIONS&gt;

DESCRIPTION:
    Query client consensus state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -c, --consensus-height    CONSENSUS-HEIGHT
    -s, --heights-only        show only consensus heights
    -h, --height HEIGHT       the chain height context to be used, applicable only to a specific height
</code></pre>
<p><strong>Example</strong></p>
<p>Query the states of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client consensus ibc-0 07-tendermint-0 --heights-only
</code></pre>
<pre><code class="language-json">Success: [
    Height {
        revision: 1,
        height: 3049,
    },
    Height {
        revision: 1,
        height: 2888,
    },
    Height {
        revision: 1,
        height: 2736,
    },
    Height {
        revision: 1,
        height: 2729,
    },
    Height {
        revision: 1,
        height: 2724,
    },
    Height {
        revision: 1,
        height: 2717,
    },
]
</code></pre>
<p>Query <code>ibc-0</code> at height <code>2800</code> for the consensus state for height <code>2724</code>:</p>
<pre><code class="language-shell">hermes query client consensus ibc-0 07-tendermint-0 -c 2724 -h 2800
</code></pre>
<pre><code class="language-json">Success: ConsensusState {
    timestamp: Time(
        2021-04-13T14:11:20.969154Z
    ),
    root: CommitmentRoot(
        &quot;371DD19003221B60162D42C78FD86ABF95A572F3D9497084584B75F97B05B70C&quot;
    ),
    next_validators_hash: Hash::Sha256(
        740950668B6705A136D041914FC219045B1D0AD1C6A284C626BF5116005A98A7
    ),
}
</code></pre>
<h2><a class="header" href="#query-the-identifiers-of-all-connections-associated-with-a-given-client" id="query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></h2>
<p>Use the <code>query client connections</code> command to query the connections associated with a given client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query client connections

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -h, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connections of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client connections ibc-0 07-tendermint-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    ConnectionId(&quot;connection-0&quot;),
    ConnectionId(&quot;connection-1&quot;),
]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#query-for-the-header-used-in-a-client-update-at-a-certain-height" id="query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></h2>
<pre><code>USAGE:
    hermes query client header &lt;OPTIONS&gt;

DESCRIPTION:
    Query for the header used in a client update at a certain height

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query
    consensus_height          height of header to query

FLAGS:
    -h, --height HEIGHT       the chain height context for the query
</code></pre>
<p><strong>Example</strong></p>
<p>Query for the header used in the <code>07-tendermint-0</code> client update at height 2724 on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client header ibc-0 07-tendermint-0 2724
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 0,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 2724,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#table-of-contents-6" id="table-of-contents-6">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/connection.html#query-connections">Query Connections</a></li>
<li><a href="commands/queries/connection.html#query-connection-data">Query Connection Data</a>
<ul>
<li><a href="commands/queries/connection.html#query-the-connection-end-data">Query the connection end data</a></li>
<li><a href="commands/queries/connection.html#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-connections" id="query-connections">Query Connections</a></h1>
<p>Use the <code>query connections</code> command to query the identifiers of all connections on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all connections on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all connections on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connections ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    ConnectionId(
        &quot;connection-0&quot;,
    ),
    ConnectionId(
        &quot;connection-1&quot;,
    ),
]
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#query-connection-data" id="query-connection-data">Query Connection Data</a></h1>
<p>Use the <code>query connection</code> commands to query a specific connection.</p>
<pre><code class="language-shell">USAGE:
    hermes query connection &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about connection(s)

SUBCOMMANDS:
    end        query connection end
    channels   query connection channels
</code></pre>
<h2><a class="header" href="#query-the-connection-end-data" id="query-the-connection-end-data">Query the connection end data</a></h2>
<p>Use the <code>query connection end</code> command to query the connection end:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection end &lt;OPTIONS&gt;

DESCRIPTION:
    query connection end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connection end of connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: ConnectionEnd {
    state: Open,
    client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    counterparty: Counterparty {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: Some(
            ConnectionId(
                &quot;connection-0&quot;,
            ),
        ),
        prefix: ibc,
    },
    versions: [
        Version {
            identifier: &quot;1&quot;,
            features: [
                &quot;ORDER_ORDERED&quot;,
                &quot;ORDER_UNORDERED&quot;,
            ],
        },
    ],
    delay_period: 0ns,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#query-the-identifiers-of-all-channels-associated-with-a-given-connection" id="query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></h2>
<p>Use the <code>query connection channels</code> command to query the identifiers of the channels associated with a given connection:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection channels &lt;OPTIONS&gt;

DESCRIPTION:
    query connection channels

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channels associated with connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection channels ibc-1 connection-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    ChannelId(
        &quot;channel-1&quot;,
    ),
]
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#table-of-contents-7" id="table-of-contents-7">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/channel.html#query-channels">Query Channels</a></li>
<li><a href="commands/queries/channel.html#query-channel-data">Query Channel Data</a>
<ul>
<li><a href="commands/queries/channel.html#query-the-channel-end-data">Query the channel end data</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-channels" id="query-channels">Query Channels</a></h1>
<p>Use the <code>query channels</code> command to query the identifiers of all channels on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query channels &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all channels on a given chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all channels on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channels ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    ChannelId(
        &quot;channel-0&quot;,
    ),
    ChannelId(
        &quot;channel-1&quot;,
    ),
]
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#query-channel-data" id="query-channel-data">Query Channel Data</a></h1>
<p>Use the <code>query channel</code> commands to query the information about a specific channel.</p>
<pre><code class="language-shell">USAGE:
    hermes query channel &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about channels

SUBCOMMANDS:
    end        query channel end
</code></pre>
<h2><a class="header" href="#query-the-channel-end-data" id="query-the-channel-end-data">Query the channel end data</a></h2>
<p>Use the <code>query channel end</code> command to query the channel end:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel end &lt;OPTIONS&gt;

DESCRIPTION:
    Query channel end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channel end ibc-1 channel-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: ChannelEnd {
    state: Open,
    ordering: Unordered,
    remote: Counterparty {
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: Some(
            ChannelId(
                &quot;channel-0&quot;,
            ),
        ),
    },
    connection_hops: [
        ConnectionId(
            &quot;connection-1&quot;,
        ),
    ],
    version: &quot;ics20-1&quot;,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#packet-queries" id="packet-queries">Packet Queries</a></h1>
<p>Use the <code>query packet</code> commands to query information about packets.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about packets

SUBCOMMANDS:
    commitments          Query packet commitments
    commitment           Query packet commitment
    acks                 Query packet acknowledgments
    ack                  Query packet acknowledgment
    unreceived-packets   Query unreceived packets
    unreceived-acks      Query unreceived acknowledgments
</code></pre>
<h2><a class="header" href="#table-of-contents-8" id="table-of-contents-8">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/packet.html#packet-commitments">Packet Commitments</a></li>
<li><a href="commands/queries/packet.html#packet-commitment-with-sequence">Packet Commitment with Sequence</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgments">Packet Acknowledgments</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></li>
<li><a href="commands/queries/packet.html#unreceived-packets">Unreceived Packets</a></li>
<li><a href="commands/queries/packet.html#unreceived-acknowledgments">Unreceived Acknowledgments</a></li>
</ul>
<h2><a class="header" href="#packet-commitments" id="packet-commitments">Packet Commitments</a></h2>
<p>Use the <code>query packet commitments</code> command to query the sequence numbers of all packets that have been sent but not yet acknowledged (these are the packets that still have their commitments stored).</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitments &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets that still have commitments on <code>ibc-0</code> and that were sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitments ibc-0 transfer channel-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: PacketSeqs {
    height: Height {
        revision: 0,
        height: 9154,
    },
    seqs: [
        1,
        2,
        3
    ],
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#packet-commitment-with-sequence" id="packet-commitment-with-sequence">Packet Commitment with Sequence</a></h2>
<p>Use the <code>query packet commitment</code> command to query the commitment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitment &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the commitment of packet with sequence <code>3</code> sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitment ibc-0 transfer channel-0 3
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: &quot;F9458DC7EBEBCD6D18E983FCAB5BD752CC2A74532BBD50B812DB229997739EFC&quot;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#packet-acknowledgments" id="packet-acknowledgments">Packet Acknowledgments</a></h2>
<p>Use the <code>query packet acknowledgments</code> command to query the sequence numbers of all packets that have been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets acknowledged that were received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet acks ibc-1 transfer channel-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: PacketSeqs {
    height: Height {
        revision: 1,
        height: 9547,
    },
    seqs: [
        1,
        2,
        3
    ],
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#packet-acknowledgment-with-sequence" id="packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></h2>
<p>Use the <code>query packet acknowledgment</code> command to query the acknowledgment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet ack &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the acknowledgment of packet with sequence <code>2</code> received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet ack ibc-1 transfer channel-1 2
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: &quot;08F7557ED51826FE18D84512BF24EC75001EDBAF2123A477DF72A0A9F3640A7C&quot;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unreceived-packets" id="unreceived-packets">Unreceived Packets</a></h2>
<p>Use the <code>query packet unreceived-packets</code> command to query the sequence numbers of all packets that have been sent on the source chain but not yet received on the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-packets &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the chain to query the unreceived sequences
    src_chain_id              identifier of the chain where sent sequences are queried
    src_port_id               identifier of the port to query on source chain
    src_channel_id            identifier of the channel to query on source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets sent on <code>ibc-0</code> on <code>transfer</code> port and <code>channel-0</code> but not yet received:</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<h2><a class="header" href="#unreceived-acknowledgments" id="unreceived-acknowledgments">Unreceived Acknowledgments</a></h2>
<p>Use the <code>query packet unreceived-acks</code> command to query the sequence numbers of all packets that have been received by the source chain but not yet acknowledged by the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived acknowledgments

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the chain to query the unreceived acknowledgments
    src_chain_id              identifier of the chain where received sequences are queried
    src_port_id               identifier of the port to query on source chain
    src_channel_id            identifier of the channel to query on source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets received on <code>ibc-1</code> on <code>transfer</code> port and <code>channel-1</code> but not yet acknowledged on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<h1><a class="header" href="#raw-transactions" id="raw-transactions">Raw Transactions</a></h1>
<p>There are a number of simple commands that perform minimal validation, build and send IBC transactions.</p>
<p>The <code>tx raw</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create-client</code></td><td><a href="commands/raw/./client.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update-client</code></td><td><a href="commands/raw/./client.html#update-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>conn-init</code></td><td><a href="commands/raw/./connection.html#connection-init">Initialize a connection (ConnectionOpenInit)</a></td></tr>
<tr><td><code>conn-try</code></td><td><a href="commands/raw/./connection.html#connection-try">Relay the connection attempt (ConnectionOpenTry)</a></td></tr>
<tr><td><code>conn-ack</code></td><td><a href="commands/raw/./connection.html#connection-ack">Relay acknowledgment of a connection attempt (ConnectionOpenAck)</a></td></tr>
<tr><td><code>conn-confirm</code></td><td><a href="commands/raw/./connection.html#connection-confirm">Confirm opening of a connection (ConnectionOpenConfirm)</a></td></tr>
<tr><td><code>chan-open-init</code></td><td><a href="commands/raw/./channel-open.html#channel-open-init">Initialize a channel (ChannelOpenInit)</a></td></tr>
<tr><td><code>chan-open-try</code></td><td><a href="commands/raw/./channel-open.html#channel-open-try">Relay the channel attempt (ChannelOpenTry)</a></td></tr>
<tr><td><code>chan-open-ack</code></td><td><a href="commands/raw/./channel-open.html#channel-open-ack">Relay acknowledgment of a channel attempt (ChannelOpenAck)</a></td></tr>
<tr><td><code>chan-open-close</code></td><td><a href="commands/raw/./channel-open.html#channel-open-close">Confirm opening of a channel (ChannelOpenConfirm)</a></td></tr>
<tr><td><code>chan-close-init</code></td><td><a href="commands/raw/./channel-close.html#channel-close-init">Initiate the closing of a channel (ChannelCloseInit)</a></td></tr>
<tr><td><code>chan-close-confirm</code></td><td><a href="commands/raw/./channel-close.html#channel-close-confirm">Confirm the closing of a channel (ChannelCloseConfirm)</a></td></tr>
<tr><td><code>ft-transfer</code></td><td><a href="commands/raw/./packet.html#fungible-token-transfer">Send a fungible token transfer test transaction (ICS20 MsgTransfer</a></td></tr>
<tr><td><code>packet-recv</code></td><td><a href="commands/raw/./packet.html#relay-receive-and-timeout-packets">Relay receive or timeout packets</a></td></tr>
<tr><td><code>packet-ack</code></td><td><a href="commands/raw/./packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></td></tr>
</tbody></table>
<p>The main purpose of these commands is to support development and testing, and continuous integration. These CLIs take quite a few parameters and they are explained in the individual sub-sections.</p>
<p>At a high level, most commands follow this template:</p>
<pre><code class="language-shell">hermes tx raw &lt;ibc-datagram&gt; &lt;dst-chain-id&gt; &lt;src-chain-id&gt; [-d &lt;dst-obj-id&gt; -s &lt;src-obj-id&gt;]*
</code></pre>
<p>In the command template above:</p>
<ul>
<li>
<p><code>ibc-datagram</code> - identifies the &quot;main&quot; IBC message that is being sent, e.g. <code>conn-init</code>, <code>conn-try</code>, <code>chan-open-init</code>, etc. To ensure successful processing on the receiving chain, the majority of these commands build and send two messages: one <code>UpdateClient</code> message followed by the actual IBC message. These two messages are included in a single transaction. This is done for all IBC datagrams that include proofs collected from the source chain.</p>
<p>The messages that do not require proofs are:</p>
<ul>
<li><code>MsgCreateClient</code> (<code>create-client</code> command),</li>
<li><code>MsgConnectionOpenInit</code> (<code>conn-open-init</code> command),</li>
<li><code>MsgChannelOpenInit</code> (<code>chan-open-init</code> command),</li>
<li><code>MsgChannelCloseInit</code> (<code>chan-close-init</code> command) and</li>
<li><code>MsgTransfer</code> (<code>ft-transfer</code> command)</li>
</ul>
</li>
<li>
<p><code>dst-chain-id</code> - is the identifier of the chain where the transaction will be sent.</p>
</li>
<li>
<p><code>src-chain-id</code> - is the identifier of the chain that is queried for the data that is included in the transaction, e.g. connection data, client proofs, etc. To ensure correct on-chain state, the relayer also queries the destination chain, however it does not include this information in the Tx to the destination chain.</p>
</li>
<li>
<p><code>dst-obj-id</code> - the identifier of an object on destination chain required by the datagram, e.g. the <code>client-id</code> associated with the connection on destination chain in connection datagrams. Or the <code>connection-id</code> in a <code>ConnOpenAck</code> datagram.</p>
</li>
<li>
<p><code>src-obj-id</code> - the identifier of an object on the source chain, required by the datagram, e.d. the <code>client-id</code> of the connection on source chain.</p>
</li>
<li>
<p>More details about the <code>tx raw</code> commands can be found in the following sections:</p>
<ul>
<li><a href="commands/raw/./client.html">Client</a></li>
<li><a href="commands/raw/./connection.html">Connection</a></li>
<li><a href="commands/raw/./channel-open.html">Channel Open</a></li>
<li><a href="commands/raw/./channel-close.html">Channel Close</a></li>
<li><a href="commands/raw/./packet.html">Packet</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<pre><code class="language-shell">USAGE:
    hermes tx raw &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Raw commands for sending transactions to a configured chain.

SUBCOMMANDS:
    help                Get usage information
    create-client       Create a client for source chain on destination chain
    update-client       Update the specified client on destination chain
    conn-init           Initialize a connection (ConnectionOpenInit)
    conn-try            Relay the connection attempt (ConnectionOpenTry)
    conn-ack            Relay acknowledgment of a connection attempt (ConnectionOpenAck)
    conn-confirm        Confirm opening of a connection (ConnectionOpenConfirm)
    chan-open-init      Initialize a channel (ChannelOpenInit)
    chan-open-try       Relay the channel attempt (ChannelOpenTry)
    chan-open-ack       Relay acknowledgment of a channel attempt (ChannelOpenAck)
    chan-open-confirm   Confirm opening of a channel (ChannelOpenConfirm)
    chan-close-init     Initiate the closing of a channel (ChannelCloseInit)
    chan-close-confirm  Confirm the closing of a channel (ChannelCloseConfirm)
    ft-transfer         Send a fungible token transfer test transaction (ICS20 MsgTransfer)
    packet-recv         Relay receive or timeout packets
    packet-ack          Relay acknowledgment packets
</code></pre>
<h1><a class="header" href="#client-1" id="client-1">Client</a></h1>
<p>The <code>tx raw</code> commands can be used to create and update the on-chain IBC clients.</p>
<h2><a class="header" href="#table-of-contents-9" id="table-of-contents-9">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/client.html#create-client">Create Client</a></li>
<li><a href="commands/raw/client.html#update-client">Update Client</a></li>
</ul>
<h2><a class="header" href="#create-client-1" id="create-client-1">Create Client</a></h2>
<p>Use the <code>create-client</code> command to create a new client.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw create-client &lt;OPTIONS&gt;

DESCRIPTION:
    Create a client for source chain on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain

</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client of <code>ibc-1</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    Success: CreateClient(
        CreateClient(
            Attributes {
                height: Height { revision: 0, height: 43 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 1, height: 32 },
            },
        ),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>A new client is created with identifier <code>07-tendermint-0</code></p>
<h2><a class="header" href="#update-client-1" id="update-client-1">Update Client</a></h2>
<p>Use the <code>update-client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw update-client &lt;OPTIONS&gt;

DESCRIPTION:
    Update the specified client on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be updated on destination chain

FLAGS:
    -h, --target-height TARGET-HEIGHT
    -t, --trusted-height TRUSTED-HEIGHT
</code></pre>
<p><strong>Example</strong></p>
<p>Update the client on <code>ibc-0</code> with latest header of <code>ibc-1</code></p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 110 },
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 109 },
        },
        header: Some(
            Tendermint(...),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-0</code> has been updated with the consensus state at height <code>1-273</code>.</p>
<h1><a class="header" href="#connection-handshake" id="connection-handshake">Connection Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a connection between two clients.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No connection
    A-&gt;&gt;B: ConnectionOpenInit
    Note over B: connection: connection-0
    Note over B: counterparty: none
    B-&gt;&gt;A: ConnectionOpenTry
    Note over A: connection: connection-1
    Note over A: counterparty: connection-0
    A-&gt;&gt;B: ConnectionOpenAck
    note over B: connection: connection-0
    note over B: counterparty: connection-1
    B-&gt;&gt;A: ConnectionOpenConfirm
    Note over A, B: Connection open
</pre>
</center>
<h2><a class="header" href="#table-of-contents-10" id="table-of-contents-10">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/connection.html#connection-init">Connection Init</a></li>
<li><a href="commands/raw/connection.html#connection-try">Connection Try</a></li>
<li><a href="commands/raw/connection.html#connection-ack">Connection Ack</a></li>
<li><a href="commands/raw/connection.html#connection-confirm">Connection Confirm</a></li>
</ul>
<h2><a class="header" href="#connection-init" id="connection-init">Connection Init</a></h2>
<p>Use the <code>conn-init</code> command to initialize a new connection on a chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a connection (ConnectionOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client
</code></pre>
<p><strong>Example</strong></p>
<p>Given that two clients were previously created with identifier <code>07-tendermint-0</code> on chain <code>ibc-0</code> and
identifier <code>07-tendermint-1</code> on chain <code>ibc-1</code>, we can initialize a connection between the two clients.</p>
<p>First, let's initialize the connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 73,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>A new connection has been initialized on <code>ibc-0</code> with identifier <code>connection-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_connection_id</code> field is currently empty.</p>
</blockquote>
<h2><a class="header" href="#connection-try" id="connection-try">Connection Try</a></h2>
<p>Use the <code>conn-try</code> command to establish a counterparty to the connection on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the connection attempt (ConnectionOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>connection-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -s connection-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 88,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>A new connection has been created on <code>ibc-1</code> with identifier <code>connection-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> points to the connection on <code>ibc-0</code>.</p>
</blockquote>
<h2><a class="header" href="#connection-ack" id="connection-ack">Connection Ack</a></h2>
<p>Use the <code>conn-ack</code> command to acknowledge the connection on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a connection attempt (ConnectionOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the connection attempt:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 206,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> now points to the connection on <code>ibc-1</code>.</p>
</blockquote>
<h2><a class="header" href="#connection-confirm" id="connection-confirm">Connection Confirm</a></h2>
<p>Use the <code>conn-confirm</code> command to confirm that the connection has been acknowledged,
and finish the handshake, after which the connection is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a connection (ConnectionOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the connection attempt.</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 239,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>We have now successfully established a connection between the two chains.</p>
<h1><a class="header" href="#channel-open-handshake" id="channel-open-handshake">Channel Open Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a channel for a given connection. Only <code>unordered</code> channels are currently supported.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No channel
    A-&gt;&gt;B: ChannelOpenInit
    Note over B: channel: channel-0
    Note over B: channel: counterparty: none
    B-&gt;&gt;A: ChannelOpenTry
    Note over A: channel: channel-1
    Note over A: channel: counterparty: channel-0
    A-&gt;&gt;B: ChannelOpenAck
    note over B: channel: channel-0
    note over B: counterparty: channel-1
    B-&gt;&gt;A: ChannelOpenConfirm
    Note over A, B: Channel open
</pre>
</center>
<h2><a class="header" href="#table-of-contents-11" id="table-of-contents-11">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/channel-open.html#channel-open-init">Channel Open Init</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-try">Channel Open Try</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-ack">Channel Open Ack</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-confirm">Channel Open Confirm</a></li>
</ul>
<h2><a class="header" href="#channel-open-init" id="channel-open-init">Channel Open Init</a></h2>
<p>Use the <code>chan-open-init</code> command to initialize a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a channel (ChannelOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -o, --order ORDER         the channel ordering, valid options 'unordered' (default) and 'ordered'
</code></pre>
<p><strong>Example</strong></p>
<p>First, let's initialize the channel on <code>ibc-0</code> using an existing connection identified by <code>connection-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 3091
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>A new channel has been initialized on <code>ibc-1</code> with identifier <code>channel-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_channel_id</code> field is currently empty.</p>
</blockquote>
<h2><a class="header" href="#channel-open-try" id="channel-open-try">Channel Open Try</a></h2>
<p>Use the <code>chan-open-try</code> command to establish a counterparty to the channel on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the channel attempt (ChannelOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>channel-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 3213
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>A new channel has been created on <code>ibc-1</code> with identifier <code>channel-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> points to the channel on <code>ibc-0</code>.</p>
</blockquote>
<h2><a class="header" href="#channel-open-ack" id="channel-open-ack">Channel Open Ack</a></h2>
<p>Use the <code>chan-open-ack</code> command to acknowledge the channel on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a channel attempt (ChannelOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the opening of the channel:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 3301
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> now points to the channel on <code>ibc-1</code>.</p>
</blockquote>
<h2><a class="header" href="#channel-open-confirm" id="channel-open-confirm">Channel Open Confirm</a></h2>
<p>Use the <code>chan-open-confirm</code> command to confirm that the channel has been acknowledged,
and finish the handshake, after which the channel is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a channel (ChannelOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the opening of the channel,
after which the channel is open on both chains.</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 3483
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p>We have now successfully opened a channel over an existing connection between the two chains.</p>
<h1><a class="header" href="#channel-close-handshake" id="channel-close-handshake">Channel Close Handshake</a></h1>
<p>The channel close handshake involves two steps: init and confirm.</p>
<h2><a class="header" href="#table-of-contents-12" id="table-of-contents-12">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/channel-close.html#channel-close-init">Channel Close Init</a></li>
<li><a href="commands/raw/channel-close.html#channel-close-confirm">Channel Close Confirm</a></li>
</ul>
<h2><a class="header" href="#channel-close-init" id="channel-close-init">Channel Close Init</a></h2>
<p>Use the <code>chan-close-init</code> command to initialize the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initiate the closing of a channel (ChannelCloseInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: CloseInitChannel(
    CloseInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 77,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#channel-close-confirm" id="channel-close-confirm">Channel Close Confirm</a></h2>
<p>Use the <code>chan-close-confirm</code> command to confirm the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm the closing of a channel (ChannelCloseConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: CloseConfirmChannel(
    CloseConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 551,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
<span class="boring">}
</span></code></pre></pre>
<p><strong>NOTE</strong>: The <code>cosmos-sdk</code> transfer module implementation does not allow the user (<code>hermes</code> in this case) to initiate the closing of channels.
Therefore, when using the Gaia release image, the <code>chan-close-init</code> command
fails as the <code>MsgChannelCloseInit</code> message included in the transaction is rejected.
To be able to test channel closure, you need to <a href="commands/raw/../../help.html#patching-gaia">patch</a> your gaia deployments.</p>
<h1><a class="header" href="#packet-tx-commands" id="packet-tx-commands">Packet Tx Commands</a></h1>
<h2><a class="header" href="#table-of-contents-13" id="table-of-contents-13">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/packet.html#fungible-token-transfer">Fungible token transfer</a></li>
<li><a href="commands/raw/packet.html#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></li>
<li><a href="commands/raw/packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></li>
</ul>
<h2><a class="header" href="#fungible-token-transfer" id="fungible-token-transfer">Fungible token transfer</a></h2>
<p>Use the <code>tx raw ft-transfer</code> command to send ICS-20 fungible token transfer packets.
<strong>NOTE:</strong> This command is mainly used for testing the packet features of the relayer.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw ft-transfer &lt;OPTIONS&gt;

DESCRIPTION:
    Send a fungible token transfer test transaction (ICS20 MsgTransfer)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
    amount                    amount of coins (samoleans, by default) to send (e.g. `100000`)
    height_offset             timeout in number of blocks since current

FLAGS:
    -r, --receiver RECEIVER   receiving account address on the destination chain
    -d, --denom DENOM         denomination of the coins to send (default: samoleans)
    -n, --number-msgs NUMBER-MSGS
</code></pre>
<p><strong>Example</strong></p>
<p>Send two transfer packets from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer if for <code>9999</code> samoleans (default denomination) and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the relayer account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 2
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
<p>The transfer packets are stored on <code>ibc-0</code> and can be relayed.</p>
<blockquote>
<p>To send transfer packets with a custom receiver address use the <code>--receiver | -r</code> flag.</p>
</blockquote>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 1 -r board:1938586739
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 546,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(7),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#relay-receive-and-timeout-packets" id="relay-receive-and-timeout-packets">Relay receive and timeout packets</a></h2>
<p>Use the <code>tx raw packet-recv</code> command to relay the packets sent but not yet received. If the sent packets have timed out then a timeout packet is sent to the source chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-recv &lt;OPTIONS&gt;

DESCRIPTION:
    Relay receive or timeout packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the two transfer packets to the <code>ibc-1</code> module bound to the <code>transfer</code> port and the <code>channel-0</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the receive messages.</p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 1,
                    height: 439,
                },
                client_id: ClientId(
                    &quot;07-tendermint-1&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 449,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
<p>Both packets have been relayed to <code>ibc-1</code> and acknowledged.</p>
<h2><a class="header" href="#relay-acknowledgment-packets" id="relay-acknowledgment-packets">Relay acknowledgment packets</a></h2>
<p>Use the <code>tx raw packet-ack</code> command to relay acknowledgments to the original source of the packets.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the acknowledgments to the <code>ibc-0</code> module bound to the <code>transfer</code> port and the <code>channel-1</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the acknowledgments.</p>
<pre><code class="language-shell">hermes tx raw packet-ack ibc-0 ibc-1 transfer channel-1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 495,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 483,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
<span class="boring">}
</span></code></pre></pre>
<p>Both acknowledgments have been received on <code>ibc-0</code>.</p>
<h1><a class="header" href="#help" id="help">Help</a></h1>
<p>This section provides guidelines regarding troubleshooting and general
resources for getting help with <code>hermes</code>.
For this purpose, we recommend a few ideas that could be of help:</p>
<ul>
<li><a href="./help.html#profiling">profile</a> your relayer binary to identify slow methods;</li>
<li><a href="./help.html#parametrizing-the-log-output-level">configure</a> the <code>log_level</code> to help with debugging;</li>
<li><a href="./help.html#patching-gaia">patch</a> your local gaia chain(s) to enable some corner-case methods
(e.g., channel close);</li>
</ul>
<p>And if the above options do not address your specific problem:</p>
<ul>
<li>you can <a href="./help.html#new-feature-request">request a new feature</a>;</li>
<li>or consult the <a href="https://github.com/informalsystems/ibc-rs/issues">list of reported issues</a> and search by relevant
keywords to see if you're dealing with a known problem;</li>
<li>we would be grateful if you can submit a <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=bug-report.md">bug report</a>
discussing any problem you find, and from there on we can look at the
problem together;</li>
</ul>
<p>Lastly, for general questions, you can reach us at <code>hello@informal.systems</code>,
or on Twitter <a href="https://twitter.com/informalinc">@informalinc</a>.</p>
<h2><a class="header" href="#profiling" id="profiling">Profiling</a></h2>
<p>The <code>relayer</code> crate provides a <code>time!</code> macro which can be used to measure how much time is spent between the invocation of the macro and the end of the enclosing scope.</p>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>The <code>time!</code> macro has no effect unless the <code>profiling</code> feature of the <code>relayer</code> crate is enabled.</p>
<p>To enable it, one must compile the <code>relayer-cli</code> crate with the <code>--features=profiling</code> flag.</p>
<p>a) One way is to build the <code>relayer</code> binary and update the <code>hermes</code> alias to point to the executable:</p>
<pre><code class="language-shell">cd relayer-cli/
cargo build --features=profiling
</code></pre>
<p>b) Alternatively, one can use the <code>cargo run</code> command and update the alias accordingly:</p>
<pre><code class="language-shell">alias hermes='cargo run --features=profiling --manifest-path=relayer-cli/Cargo.toml --'
</code></pre>
<p>The <code>--manifest-path=relayer-cli/Cargo.toml</code> flag is needed for <code>cargo run</code> to accept the <code>--features</code> flag.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function(x: u32) -&gt; u32 {
    time!(&quot;myfunction: x={}&quot;, x); // A

    std::thread::sleep(Duration::from_secs(1));

    {
        time!(&quot;inner operation&quot;); // B

        std::thread::sleep(Duration::from_secs(2));

        // timer B ends here
    }

    x + 1

    // timer A ends here
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#output" id="output">Output</a></h4>
<pre><code>Jan 20 11:28:46.841  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - start
Jan 20 11:28:47.842  INFO relayer::macros::profiling:    ⏳ inner operation - start
Jan 20 11:28:49.846  INFO relayer::macros::profiling:    ⏳ inner operation - elapsed: 2004ms
Jan 20 11:28:49.847  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - elapsed: 3005ms
</code></pre>
<p>Profiling is useful for tracking down unusually slow methods.
Each transaction or query usually consists of multiple lower-level methods,
and it's often not clear which of these are the culprit for low performance.
With profiling enabled, <code>hermes</code> will output timing information for individual
methods involved in a command.</p>
<p><strong>NOTE</strong>: To be able to see the profiling output, the realyer needs to be compiled with
the <code>profiling</code> feature and the <a href="./help.html#parametrizing-the-log-output-level">log level</a> should be <code>info</code> level or lower.</p>
<h4><a class="header" href="#example-output-for-tx-raw-conn-init-command" id="example-output-for-tx-raw-conn-init-command">Example output for <code>tx raw conn-init</code> command</a></h4>
<pre><code>hermes -c config_example.toml tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-0
</code></pre>
<pre><code>Apr 13 20:58:21.225  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 4ms
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.235  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 5ms
Apr 13 20:58:21.235  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-1
Apr 13 20:58:21.236  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 2ms
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 4ms
Apr 13 20:58:21.244  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-0
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ get_signer - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ get_signer - elapsed: 1ms
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.248  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 1ms
Apr 13 20:58:21.249  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - elapsed: 3ms
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - start
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.251  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 0ms
Apr 13 20:58:21.270  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 2ms
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - elapsed: 23ms
Apr 13 20:58:21.279  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - elapsed: 0ms
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:          ⏳ block_on - start
Apr 13 20:58:21.285  INFO ibc_relayer::macros::profiling:          ⏳ block_on - elapsed: 3ms
Apr 13 20:58:21.296  INFO ibc_relayer::macros::profiling:             ⏳ block_on - start
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:             ⏳ block_on - elapsed: 1367ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - elapsed: 1382ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - elapsed: 1384ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - elapsed: 1384ms
Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 10675,
            },
            client_id: ClientId(
                &quot;07-tendermint-7&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 10663,
            },
        },
    ),
)
</code></pre>
<h2><a class="header" href="#parametrizing-the-log-output-level" id="parametrizing-the-log-output-level">Parametrizing the log output level</a></h2>
<p>The relayer configuration file permits parametrization of output verbosity via the knob called <code>log_level</code>.
This file is loaded by default from <code>$HOME/.hermes/config.toml</code>, but can be overridden in all commands
with the <code>-c</code> flag, eg. <code>hermes -c ./path/to/my/config.toml some command</code>.</p>
<p>Relevant snippet:</p>
<pre><code class="language-toml">[global]
strategy = 'naive'
log_level = 'error'
</code></pre>
<p>Valid options for <code>log_level</code> are: 'error', 'warn', 'info', 'debug', 'trace'.
These levels correspond to the tracing sub-component of the relayer-cli,
<a href="https://docs.rs/tracing-core/0.1.17/tracing_core/struct.Level.html">see here</a>.</p>
<p>The relayer will <em>always</em> print a last line summarizing the result of its
operation for queries of transactions. In addition to  this last line,
arbitrary debug, info, or other outputs may be produced.  Example, with
<code>log_level = 'debug'</code> and JSON output:</p>
<pre><code class="language-bash">{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.070&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: abscissa_core::terminal::component::Terminal (v0.5.2)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.071&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: relayer_cli::components::Tracing (v0.0.6)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.078&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Options QueryClientConsensusOptions { client_id: ClientId(\&quot;07-tendermint-X\&quot;), revision_number: 0, revision_height: 1, height: 0, proof: true }&quot;},&quot;target&quot;:&quot;relayer_cli::commands::query::client&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.080&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;resolving host=\&quot;localhost\&quot;&quot;},&quot;target&quot;:&quot;hyper::client::connect::dns&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to [::1]:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to 127.0.0.1:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<p>For the same command, with <code>log_level = 'error'</code>, just the last line will be
produced:</p>
<pre><code class="language-bash">{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<h2><a class="header" href="#patching-gaia" id="patching-gaia">Patching <code>gaia</code></a></h2>
<p>The guide below refers specifically to patching your gaia chain so that the
relayer can initiate the closing of channels by submitting a <a href="./commands/raw/channel-close.html#channel-close-init"><code>chan-close-init</code> transaction</a>.
Without this modification, the transaction will be rejected.
We also describe how to test the channel closing feature.</p>
<ul>
<li>
<p>Clone the Cosmos SDK</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/cosmos-sdk.git ~/go/src/github.com/cosmos/cosmos-sdk
cd ~/go/src/github.com/cosmos/cosmos-sdk
</code></pre>
</li>
<li>
<p>Apply these diffs:</p>
<pre><code>   --- a/x/ibc/applications/transfer/module.go
   +++ b/x/ibc/applications/transfer/module.go
   @@ -305,7 +305,7 @@ func (am AppModule) OnChanCloseInit(
           channelID string,
    ) error {
           // Disallow user-initiated channel closing for transfer channels
   -       return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, &quot;user cannot close channel&quot;)
   +       return nil
    }
</code></pre>
</li>
<li>
<p>Append the line below (watch for the placeholder <code>&lt;your&gt;</code>) as the last line
in your <code>go.mod</code> in the gaia clone:</p>
</li>
</ul>
<p><code>replace github.com/cosmos/cosmos-sdk =&gt; /Users/&lt;your&gt;/go/src/github.com/cosmos/cosmos-sdk</code></p>
<ul>
<li>Now <code>make build</code> and <code>make install</code> your local copy of gaia</li>
</ul>
<p>In order to test the correct operation during the channel close, perform the steps below.</p>
<ul>
<li>
<p>the channel should be in state open-open:</p>
</li>
<li>
<p>transfer of 5555 samoleans from <code>ibc-1</code> to <code>ibc-0</code>. This results in a
Tx to <code>ibc-1</code> for a <code>MsgTransfer</code> packet.
Make sure you're not relaying this packet (the relayer should not be running on
this path).</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 5555 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>now do the first step of channel closing: the channel will transition
to close-open:</p>
<pre><code class="language-shell">hermes -c config.toml tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer channel-0 channel-1
</code></pre>
</li>
<li>
<p>trigger timeout on close to ibc-1</p>
<pre><code class="language-shell">hermes -c config.toml tx raw packet-recv ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>close-close</p>
<pre><code class="language-shell">hermes -c config.toml tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer channel-1 channel-0
</code></pre>
</li>
<li>
<p>verify that the two ends are in Close state:</p>
<pre><code class="language-shell">hermes -c config.toml query channel end ibc-0 transfer channel-0
hermes -c config.toml query channel end ibc-1 transfer channel-1
</code></pre>
</li>
</ul>
<h2><a class="header" href="#new-feature-request" id="new-feature-request">New Feature Request</a></h2>
<p>If you would like a feature to be added to <code>hermes</code>, don't hesitate
to open a discussion about that via the <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=feature-request.md">feature request</a>
issue template.</p>
<blockquote>
<p>Note that Hermes is packaged as part of the <code>ibc-relayer-cli</code> crate.</p>
</blockquote>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>These are some of the definitions used in this guide: </p>
<table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td>IBC transaction</td><td>A transaction that includes IBC datagrams (including packets). This is constructed by the relayer and sent over the physical network to a chain according to the chain rules. For example, for tendermint chains a broadcast_tx_commit request is sent to a tendermint RPC server.</td></tr>
<tr><td>IBC datagram</td><td>An element of the transaction payload sent by the relayer; it includes client, connection, channel and IBC packet data. Multiple IBC datagrams may be included in an IBC transaction.</td></tr>
<tr><td>IBC packet</td><td>A particular type of IBC datagram that includes the application packet and its commitment proof.</td></tr>
<tr><td>IBC Client</td><td>Client code running on chain, typically only the light client verification related functionality.</td></tr>
<tr><td>Relayer Light Client</td><td>Full light client functionality, including connecting to at least one provider (full node), storing and verifying headers, etc.</td></tr>
<tr><td>Source chain</td><td>The chain from which the relayer reads data to fill an IBC datagram.</td></tr>
<tr><td>Destination chain</td><td>The chain where the relayer submits transactions that include the IBC datagram.</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

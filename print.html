<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hermes (IBC Relayer CLI) Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Hermes</li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="relayer.html"><strong aria-hidden="true">1.1.</strong> What is Hermes?</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feature_matrix.html"><strong aria-hidden="true">2.1.</strong> Feature matrix</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pre_requisites.html"><strong aria-hidden="true">3.1.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.3.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">4.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="two_chains.html"><strong aria-hidden="true">4.1.</strong> Two local chains</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gaia.html"><strong aria-hidden="true">4.1.1.</strong> Install Gaia</a></li><li class="chapter-item expanded "><a href="local_chains.html"><strong aria-hidden="true">4.1.2.</strong> Start the local chains</a></li><li class="chapter-item expanded "><a href="tutorial_raw.html"><strong aria-hidden="true">4.1.3.</strong> Connect the chains using raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial_client_raw.html"><strong aria-hidden="true">4.1.3.1.</strong> Configure clients</a></li><li class="chapter-item expanded "><a href="tutorial_conn_raw.html"><strong aria-hidden="true">4.1.3.2.</strong> Connection handshake</a></li><li class="chapter-item expanded "><a href="tutorial_chan_open_raw.html"><strong aria-hidden="true">4.1.3.3.</strong> Channel handshake</a></li><li class="chapter-item expanded "><a href="tutorial_packet_raw.html"><strong aria-hidden="true">4.1.3.4.</strong> Relay packets</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial_relay_paths.html"><strong aria-hidden="true">4.1.4.</strong> Connect the chains using relay paths</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial_set_new_path.html"><strong aria-hidden="true">4.1.4.1.</strong> New path</a></li><li class="chapter-item expanded "><a href="tutorial_relay_existing_path.html"><strong aria-hidden="true">4.1.4.2.</strong> Packet relaying on existing path</a></li><li class="chapter-item expanded "><a href="tutorial_relay_new_path.html"><strong aria-hidden="true">4.1.4.3.</strong> Packet relaying on new path</a></li><li class="chapter-item expanded "><a href="tutorial_relay_two_paths.html"><strong aria-hidden="true">4.1.4.4.</strong> Concurrent packet relaying on multiple paths</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">5.</strong> Commands Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keys.html"><strong aria-hidden="true">5.1.</strong> Keys</a></li><li class="chapter-item expanded "><a href="light_clients.html"><strong aria-hidden="true">5.2.</strong> Light clients</a></li><li class="chapter-item expanded "><a href="relayer_loop.html"><strong aria-hidden="true">5.3.</strong> Path setup and streaming</a></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">5.4.</strong> Raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tx_client.html"><strong aria-hidden="true">5.4.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="tx_connection.html"><strong aria-hidden="true">5.4.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="tx_channel_open.html"><strong aria-hidden="true">5.4.3.</strong> Channel Open</a></li><li class="chapter-item expanded "><a href="tx_channel_close.html"><strong aria-hidden="true">5.4.4.</strong> Channel Close</a></li><li class="chapter-item expanded "><a href="tx_packet.html"><strong aria-hidden="true">5.4.5.</strong> Packet</a></li></ol></li><li class="chapter-item expanded "><a href="queries.html"><strong aria-hidden="true">5.5.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_client.html"><strong aria-hidden="true">5.5.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="query_connection.html"><strong aria-hidden="true">5.5.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="query_channel.html"><strong aria-hidden="true">5.5.3.</strong> Channel</a></li><li class="chapter-item expanded "><a href="query_packet.html"><strong aria-hidden="true">5.5.4.</strong> Packet</a></li></ol></li><li class="chapter-item expanded "><a href="listen.html"><strong aria-hidden="true">5.6.</strong> Listen mode</a></li></ol></li><li class="chapter-item expanded "><a href="help.html"><strong aria-hidden="true">6.</strong> Help</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">7.</strong> Glossary</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Hermes (IBC Relayer CLI) Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hermes-guide" id="hermes-guide">Hermes Guide</a></h1>
<p>This guide can help you setup, configure, and operate Hermes to transfer
packets between two IBC enabled chains.</p>
<h2><a class="header" href="#sections" id="sections">Sections</a></h2>
<hr />
<p><strong><a href="./relayer.html">What is Hermes</a></strong></p>
<ul>
<li>Explains what Hermes is about.</li>
</ul>
<p><strong><a href="./features.html">Features</a></strong></p>
<ul>
<li>This section discusses what features to expect from Hermes, as well as a
comparison between the Cosmos Go relayer and Hermes.</li>
</ul>
<p><strong><a href="./getting_started.html">Getting Started</a></strong></p>
<ul>
<li>The getting started section can help you setup, configure, and run Hermes.</li>
</ul>
<p><strong><a href="./tutorials.html">Tutorials</a></strong></p>
<ul>
<li>This section provides some tutorials on how to operate and test Hermes.</li>
</ul>
<p><strong><a href="./commands.html">Commands Reference</a></strong></p>
<ul>
<li>The commands let you interact with Hermes using its command line interface.</li>
</ul>
<p><strong><a href="./help.html">Help</a></strong></p>
<ul>
<li>This part provides guidelines regarding troubleshooting and general resources
for getting help.</li>
</ul>
<p><strong><a href="./glossary.html">Glossary</a></strong></p>
<ul>
<li>This section provides some definitions of terms used throughout the guide</li>
</ul>
<hr />
<p><strong>Other References and Useful Links:</strong></p>
<ul>
<li><a href="https://github.com/informalsystems/ibc-rs">Hermes Github repository</a> — The
official Github repository for Hermes.</li>
<li><a href="https://github.com/cosmos/ics">IBC Github repository</a> - The official
repository for the Inter-blockchain protocol (IBC).</li>
</ul>
<h2><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h2>
<p>This project is undergoing heavy development, use at your own risk.</p>
<h1><a class="header" href="#what-is-hermes" id="what-is-hermes">What is Hermes?</a></h1>
<p>Hermes is a an open-source Rust implementation of a relayer for the <a href="https://cosmos.network/ibc">Inter-Blockchain Communication protocol</a> (IBC),
released under the <a href="https://crates.io/crates/ibc-relayer-cli">ibc-relayer-cli</a> crate.</p>
<p>The <strong>Inter-Blockchain Communication protocol</strong> is an end-to-end, connection-oriented,
state-ful protocol for reliable, ordered, and authenticated communication between modules
on separate distributed ledgers. <sup class="footnote-reference"><a href="#ibc">1</a></sup></p>
<p>An IBC <strong>relayer</strong> is an off-chain process responsible for relaying IBC datagrams between any two chains.
The way it does so is by scanning chain states, building transactions based on these states,
and submitting the transactions to the chains involved in the network.</p>
<p>The relayer is a central element in the IBC network architecture. This is because chain modules
in this architecture are not directly sending messages to each other over networking infrastructure,
but instead they create and store the data to be retrieved and used by a relayer to build the IBC datagrams.</p>
<p>We sometimes refer to Hermes as &quot;IBC Relayer CLI&quot;, to make it clear that this
is a relayer CLI (i.e., a binary) and distinguish from the relayer core library
(which is the crate called <a href="https://crates.io/crates/ibc-relayer"><code>ibc-relayer</code></a>).</p>
<p>Hermes is actively developed and maintained by <a href="https://informal.systems">Informal Systems</a> in the <a href="https://github.com/informalsystems/ibc-rs">ibc-rs</a> repository.</p>
<div class="footnote-definition" id="ibc"><sup class="footnote-definition-label">1</sup>
<p><a href="https://arxiv.org/pdf/2006.15918.pdf">The Interblockchain Communication Protocol: An Overview</a></p>
</div>
<h1><a class="header" href="#features" id="features">Features</a></h1>
<p>This section includes a summary of the supported and planned features.
More details and feature comparison between the Rust and Go relayer implementations can be found in the <a href="./feature_matrix.html">Feature Matrix</a></p>
<h2><a class="header" href="#supported-features" id="supported-features">Supported Features</a></h2>
<ul>
<li>
<p>Establish a new relaying path (new clients, connection and unordered channel handshake)</p>
</li>
<li>
<p>Relay from packet events on a newly created, or an existing relaying path</p>
<p><strong>Limitations:</strong></p>
<ul>
<li>Supports only one path per relayer instance</li>
<li>Relayer restart is not supported, i.e. pending packets (previously sent packets and acknowledgments) are not cleared on startup</li>
<li>Only unordered channels are supported</li>
</ul>
</li>
<li>
<p>individual commands that build and send transactions for:</p>
<ul>
<li>Creating and updating IBC Tendermint light clients</li>
<li>Sending connection open handshake datagrams</li>
<li>Sending channel open handshake datagrams</li>
<li>Sending channel closing handshake datagrams</li>
<li>Initiating a cross chain transfer (mainly for testing)</li>
<li>Relaying sent packets, acknowledgments and timeouts</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#upcoming--unsupported-features" id="upcoming--unsupported-features">Upcoming / Unsupported Features</a></h2>
<p>Planned features:</p>
<ul>
<li>Support for client upgrade and unfreezing</li>
<li>Connection handshake using existing clients and/or existing connection that is not in <code>Open</code> state</li>
<li>Channel handshake using existing clients, opened connection, and/ or existing channel that is not in <code>Open</code> state</li>
<li>Passive mode: relay from all IBC events</li>
<li>Support for relayer restart</li>
<li>Support for multiple paths</li>
<li>Close-to-0 configuration relayer</li>
<li>Relayer support for management application (add RPC server)</li>
</ul>
<p>Not planned:</p>
<ul>
<li>Relayer management application</li>
<li>Create clients with user chosen parameters (such as UpgradePath)</li>
<li>Monitor and submit misbehaviour for clients</li>
<li>Use IBC light clients other than Tendermint such as Solo Machine</li>
<li>Support non cosmos-SDK chains</li>
<li>Sending an UpgradePlan proposal for an IBC breaking upgrade</li>
<li>Upgrading clients after a counterparty chain has performed an upgrade for IBC breaking changes</li>
</ul>
<h1><a class="header" href="#feature-matrix" id="feature-matrix">Feature Matrix</a></h1>
<p>This section gives more details about the features and implementation status 
of Hermes in comparison with the <a href="https://github.com/cosmos/relayer">cosmos-go-relayer</a>.</p>
<p><strong>Legend</strong>:</p>
<table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody>
<tr><td>❌</td><td>feature not supported</td></tr>
<tr><td>✅</td><td>feature is supported</td></tr>
<tr><td><code>Chain</code></td><td>chain related</td></tr>
<tr><td><code>Cl</code></td><td>client related</td></tr>
<tr><td><code>Conn</code></td><td>connection related</td></tr>
<tr><td><code>Chan</code></td><td>channel related</td></tr>
<tr><td><code>.._Handshake_..</code></td><td>can execute all transactions required to finish a handshake from a single command</td></tr>
<tr><td><code>.._&lt;msg&gt;_A</code></td><td>building and sending <code>msg</code> from a command that scans chain state</td></tr>
<tr><td><code>.._&lt;msg&gt;_P</code></td><td>building and sending <code>msg</code> from IBC event; doesn't apply to <code>.._Init</code> and <code>FT_Transfer</code> features</td></tr>
</tbody></table>
<p><strong>Feature comparison between Hermes and the Go relayer</strong> </p>
<table><thead><tr><th>Features \      Status</th><th align="center">Hermes</th><th align="center">Cosmos Go</th><th align="left">Feature Details</th></tr></thead><tbody>
<tr><td>Restart</td><td align="center">❌</td><td align="center">✅</td><td align="left">replays any IBC events that happened before restart</td></tr>
<tr><td>Multiple_Paths</td><td align="center">❌</td><td align="center">✅</td><td align="left">relays on multiple paths concurrently</td></tr>
<tr><td>Chan_Unordered</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Ordered</td><td align="center">❌</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Cl_Tendermint_Create</td><td align="center">✅</td><td align="center">✅</td><td align="left">tendermint light client creation</td></tr>
<tr><td>Cl_Tendermint_Update</td><td align="center">✅</td><td align="center">✅</td><td align="left">tendermint light client update</td></tr>
<tr><td>Cl_Tendermint_Upgrade</td><td align="center">❌</td><td align="center">✅</td><td align="left">tendermint light client upgrade</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Conn_Handshake_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Handshake_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Chan_Handshake_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Handshake_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Conn_Open_Init</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Open_Try_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Open_Try_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Conn_Open_Ack_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Open_Ack_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Conn_Open_Confirm_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Conn_Open_Confirm_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Chan_Open_Init</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Open_Try_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Open_Try_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Chan_Open_Ack_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Open_Ack_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td>Chan_Open_Confirm_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Open_Confirm_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Chan_Close_Init</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Close_Confirm_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Chan_Close_Confirm_P</td><td align="center">❌</td><td align="center">❌</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>FT_Transfer</td><td align="center">✅</td><td align="center">✅</td><td align="left">can submit an ICS-20 fungible token transfer message</td></tr>
<tr><td>Packet_Recv_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Recv_P</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Timeout_A</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_Timeout_P</td><td align="center">✅</td><td align="center">✅</td><td align="left"></td></tr>
<tr><td>Packet_TimeoutClose_A</td><td align="center">✅</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td>Packet_TimeoutClose_P</td><td align="center">✅</td><td align="center">❓</td><td align="left"></td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Upgrade_Plan_Proposal</td><td align="center">❌</td><td align="center">✅</td><td align="left">submit <code>UpgradePlan</code> proposals for IBC breaking upgrades</td></tr>
<tr><td>Cl_Unfreeze_Proposal</td><td align="center">❌</td><td align="center">❌</td><td align="left">submit IBC client unfreezing proposals</td></tr>
<tr><td>Cl_Misbehavior</td><td align="center">❌</td><td align="center">❌</td><td align="left">monitors and submits IBC client misbehavior</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Cl_Non_Tendermint</td><td align="center">❌</td><td align="center">❌</td><td align="left">supports non tendermint IBC light clients</td></tr>
<tr><td>Chain_Non_Cosmos</td><td align="center">❌</td><td align="center">❌</td><td align="left">supports non cosmos-SDK chains</td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="left"></td></tr>
<tr><td>Mgmt_Static</td><td align="center">✅</td><td align="center">✅</td><td align="left">provides means for configuration prior to being started</td></tr>
<tr><td>Mgmt_Dynamic</td><td align="center">❌</td><td align="center">❌</td><td align="left">provides means for configuration and monitoring during runtime</td></tr>
</tbody></table>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>In order to run Hermes, please make sure you have all the 
<a href="./pre_requisites.html">pre-requisites</a> installed on your machine.</p>
<p>Once you have these pre-requisites, you can
<a href="./installation.html">build and run Hermes</a>.</p>
<blockquote>
<p>The instructions in this guide have been tested on <code>Linux</code> and <code>MacOS</code> 
environments. Most of the commands should work on both environments. Even 
though you can build and run the relayer on <code>Windows</code> (since we develop it 
in Rust and it supports cross platform compilation) we have not tested the 
relayer on <code>Windows</code> and we do not support this operating system at this time.</p>
</blockquote>
<h1><a class="header" href="#pre-requisites" id="pre-requisites">Pre-requisites</a></h1>
<h2><a class="header" href="#1-rust" id="1-rust">1. Rust</a></h2>
<p>The IBC Relayer is developed with the <a href="">Rust</a> programming language. In order to build and run the relayer you need to install and configure <code>Rust</code> on your machine.</p>
<h3><a class="header" href="#fresh-rust-installation" id="fresh-rust-installation">Fresh Rust installation</a></h3>
<p>For instructions on how to install <code>Rust</code> on your machine please follow the official <a href="https://www.rust-lang.org/tools/install"><code>Notes about Rust Installation</code></a>.</p>
<p>The provided instructions will install all the Rust toolchain including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> that are required to build the project.</p>
<h3><a class="header" href="#version-requirements" id="version-requirements">Version requirements</a></h3>
<p>Hermes is developed and tested using the latest version of Rust, <code>1.49</code> at 
the moment. To check that your toolchain is up-to-date run:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>In case you already had installed the Rust toolchain in the past, you can 
update your installation by running <code>rustup update</code>.</p>
<h3><a class="header" href="#testing-the-installation" id="testing-the-installation">Testing the installation</a></h3>
<p>After you install the <code>Rust</code> toolchain you can execute the following command:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<p>This should display the <code>cargo</code> version and confirm the proper installation.</p>
<h2><a class="header" href="#2-golang" id="2-golang">2. Golang</a></h2>
<p>You will also need the <strong>Go</strong> programming language installed and configured on your machine. This is a requirement for the the section <a href="./gaia.html">Installing Gaia</a> in the <a href="./two_chains.html">Two Local Chains</a> tutorial.</p>
<p>To install and configure Golang on your machine please follow the <a href="https://golang.org/doc/install">Golang official documentation</a></p>
<h2><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h2>
<p>Next, go to the <a href="./installation.html">Installation</a> section to learn how to build 
Hermes.</p>
<h1><a class="header" href="#install-the-relayer" id="install-the-relayer">Install the relayer</a></h1>
<p>There are two main approaches for obtaining Hermes:</p>
<ol>
<li>
<p>Installation:</p>
<ol>
<li>If you are running on a Unix machine (Linux/MacOS), then the simplest
option is to <a href="installation.html#Install-by-downloading">download the latest binary</a>.</li>
<li>You can also install via <a href="installation.html#install-via-cargo">Cargo</a>.</li>
</ol>
</li>
<li>
<p>Alternatively, <a href="installation.html#build-from-source">build Hermes directly from source</a>.</p>
</li>
</ol>
<h2><a class="header" href="#install-by-downloading" id="install-by-downloading">Install by downloading</a></h2>
<p>Simply head to the GitHub <a href="https://github.com/informalsystems/ibc-rs/releases">Releases</a> page and download the latest
version of Hermes binary matching your platform:</p>
<ul>
<li>MacOS: <code>hermes-v0.1.1-x86_64-apple-darwin.tar.gz</code> (or .zip),</li>
<li>Linux: <code>hermes-v0.1.1-x86_64-unknown-linux-gnu.tar.gz</code> (or .zip).</li>
</ul>
<p>The step-by-step instruction below should carry you through the whole process:</p>
<ol>
<li>
<p>Make the directory where we'll place the binary:</p>
<pre><code class="language-shell">mkdir -p $HOME/.hermes/bin
</code></pre>
</li>
<li>
<p>Extract the binary archive:</p>
<pre><code class="language-shell">tar -C $HOME/.hermes/bin/ -vxzf $ARCHIVE_NAME
</code></pre>
</li>
<li>
<p>Update your path, by adding this line in your <code>.bashrc</code> or <code>.zshrc</code> shell
configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.hermes/bin:$PATH&quot;
</code></pre>
</li>
</ol>
<blockquote>
<p>NOTE: The binary may be initially prevented from running if you're
on MacOS.
See the <a href="https://support.apple.com/en-gb/HT202491">&quot;Open Anyway&quot; instructions from this support forum</a>
if that is the case.</p>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.1.1
</code></pre>
<h2><a class="header" href="#install-via-cargo" id="install-via-cargo">Install via Cargo</a></h2>
<blockquote>
<p>NOTE: This approach assumes you have installed all
the <a href="./pre_requisites.html">pre-requisites</a> on your machine.</p>
</blockquote>
<p>Hermes is packaged in the <code>ibc-relayer-cli</code> Rust crate.
To install the latest release of Hermes, run the following command in a terminal:</p>
<pre><code class="language-shell">cargo install ibc-relayer-cli --bin hermes --locked
</code></pre>
<p>This will download and build the crate <code>ibc-relayer-cli</code>, and install the 
<code>hermes</code> binary in <code>$HOME/.cargo/bin</code>.</p>
<blockquote>
<p>If you have not installed Rust and Cargo via <a href="https://rustup.rs">rustup.rs</a>, you may need to
add the <code>$HOME/.cargo/bin</code> directory to your <code>PATH</code> environment variable.
For most shells, this can be done by adding the following line to your
<code>.bashrc</code> or <code>.zshrc</code> configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.1.1
</code></pre>
<h2><a class="header" href="#build-from-source" id="build-from-source">Build from source</a></h2>
<h3><a class="header" href="#clone-the-repository" id="clone-the-repository">Clone the repository</a></h3>
<p>Open a terminal and clone the following <code>ibc-rs</code> repository:</p>
<pre><code class="language-shell">git clone https://github.com/informalsystems/ibc-rs.git`
</code></pre>
<p>Change to the repository directory</p>
<pre><code class="language-shell">cd ibc-rs
</code></pre>
<h3><a class="header" href="#checkout-the-latest-release" id="checkout-the-latest-release">Checkout the latest release</a></h3>
<p>Go to the <a href="https://github.com/informalsystems/ibc-rs/releases">ibc-rs releases</a> page to see what is the most recent release.</p>
<p>Then checkout the release, for example if the most recent release is <code>v0.1.1</code> then execute the command:</p>
<pre><code class="language-shell">git checkout v0.1.1
</code></pre>
<h3><a class="header" href="#building-with-cargo-build" id="building-with-cargo-build">Building with <code>cargo build</code></a></h3>
<p>This command builds all the crates from the <a href="https://github.com/informalsystems/ibc-rs"><strong><code>ibc-rs</code></strong></a> repository, namely: the <a href="https://github.com/informalsystems/ibc-rs/tree/master/modules"><strong><code>ibc</code></strong></a> modules crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer"><strong><code>ibc-relayer</code></strong></a> crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/proto"><strong><code>ibc-proto</code></strong></a> crate, and the <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer-cli"><strong><code>ibc-relayer-cli</code></strong></a> crate.
The last of these crates contains the <code>hermes</code> binary.</p>
<pre><code class="language-shell">cargo build --release --bin hermes
</code></pre>
<p>If the build is successful, the <code>hermes</code> executable will be located in the following location:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<p><strong>Troubleshooting</strong>:
In case the <code>cargo build</code> command above fails, as a first course of action we
recommend trying to run the same command with the additional <code>locked</code> flag:</p>
<pre><code class="language-shell">cargo build --release --bin hermes --locked
</code></pre>
<h3><a class="header" href="#running-for-the-first-time" id="running-for-the-first-time">Running for the first time</a></h3>
<p>If you run the <code>hermes</code> without any additional parameters you should see the usage and help information:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<pre><code>hermes 0.1.1
Informal Systems &lt;hello@informal.systems&gt;

USAGE:
    hermes &lt;SUBCOMMAND&gt;

SUBCOMMANDS:
    help       Get usage information
    keys       Manage keys in the relayer for each chain
    light      Basic functionality for managing the light clients
    start      Start the relayer
    channel    Channel functionality for managing channels
    query      Query state from chain
    tx         Create and send IBC transactions
    listen     Listen to and display IBC events emitted by a chain
    version    Display version information
</code></pre>
<h3><a class="header" href="#creating-an-alias-for-the-executable" id="creating-an-alias-for-the-executable">Creating an alias for the executable</a></h3>
<p>It might be easier to create an alias for <code>hermes</code> so you can just run it by specifying the executable name instead of the whole path. In order to create an alias execute the following command:</p>
<pre><code class="language-shell">alias hermes='cargo run --release --bin hermes --'
</code></pre>
<h3><a class="header" href="#next-steps-1" id="next-steps-1">Next Steps</a></h3>
<p>Go to the <a href="./config.html"><code>Configuration</code></a> section to learn how to create a configuration file to be used by Hermes.</p>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>In order to run Hermes, you will need to have a configuration file.</p>
<p>The format supported for the configuration file is <a href="https://toml.io/en/">TOML</a>.</p>
<p>By default, Hermes expects the configuration file to be located at <code>$HOME/.hermes/config.toml</code>.</p>
<p>This can be overridden by supplying the <code>-c</code> flag when invoking <code>hermes</code>, before the
name of the command to run, eg. <code>hermes -c my_config.toml query connection channels ibc-1 connection-1</code>.</p>
<blockquote>
<p>With the exception of the light client configuration, current relayer does not support managing the configuration file programmatically.
You will need to use a text editor to create the file and add content to it.</p>
</blockquote>
<pre><code class="language-bash">hermes [-c CONFIG_FILE] COMMAND
</code></pre>
<h2><a class="header" href="#sections-1" id="sections-1">Sections</a></h2>
<p>The configuration file must have one <code>global</code> section, and one <code>chains</code> section for each chain.</p>
<h3><a class="header" href="#global" id="global"><code>[global]</code></a></h3>
<p>The global section has parameters that apply globally to the relayer operation.</p>
<h4><a class="header" href="#parameters" id="parameters">Parameters</a></h4>
<ul>
<li>
<p><strong>timeout</strong>: Specify the maximum amount of time (duration) that the operations should take before timing out. Default value is <code>10s</code> (10 seconds).</p>
</li>
<li>
<p><strong>strategy</strong>: Specify the strategy to be used by the relayer. Currently only <code>naive</code> is supported.</p>
</li>
<li>
<p><strong>log_level</strong>: Specify the verbosity for the relayer logging output. Valid options are 'error', 'warn', 'info', 'debug', 'trace'. Default value is <code>info</code>.
For more information on parametrizing the log output, see the section
<a href="./help.html#parametrizing-the-log-output-level">help/log-level</a>.</p>
</li>
</ul>
<p>Here is an example for the <code>global</code> section:</p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'info'
</code></pre>
<h3><a class="header" href="#chains" id="chains"><code>[[chains]]</code></a></h3>
<p>A <code>chains</code> section includes parameters related to a chain and the full node to which the relayer can send transactions and  queries. It also has parameters related to the light client peers configured for the chain.</p>
<h4><a class="header" href="#parameters-1" id="parameters-1">Parameters</a></h4>
<ul>
<li>
<p><strong>id</strong>: Specify the chain ID. For example <code>ibc-0</code></p>
</li>
<li>
<p><strong>rpc_addr</strong>: Specify the RPC address and port where the chain RPC server listens on. For example <code>tcp://localhost:26657</code></p>
</li>
<li>
<p><strong>grpc_addr</strong>: Specify the GRPC address and port where the chain GRPC server listens on. For example <code>tcp://localhost:9090</code></p>
</li>
<li>
<p><strong>account_prefix</strong>: Specify the prefix used by the chain. For example <code>cosmos</code></p>
</li>
<li>
<p><strong>key_name</strong>: Specify the name of the private key JSON file. This is the filename for the private key used to sign transactions on this chain. Don't specify the file extension, for example if the filename for the private key is <code>testkey.json</code>, specify only <code>testkey</code> for this parameter.</p>
</li>
<li>
<p><strong>store_prefix</strong>: Specify the store prefix used by the on-chain IBC modules. For example <code>ibc</code>.</p>
</li>
<li>
<p><strong>gas</strong>: Specify the maximum amount of gas to be used as the gas limit for a transaction. Default value is <code>300000</code></p>
</li>
<li>
<p><strong>clock_drift</strong>: Specify the maximum amount of time to tolerate a clock drift. The clock drift parameter defines how much new (untrusted) header's Time can drift into the future. Default value is <code>5s</code></p>
</li>
<li>
<p><strong>trusting_period</strong>: Specify the amount of time to be used as the trusting period. It should be significantly less than the unbonding period (e.g. unbonding period = 3 weeks, trusting period = 2 weeks). Default value is <code>14days</code> (336 hours)</p>
</li>
</ul>
<p>For example if you want to add a configuration for a chain named <code>ibc-0</code>:</p>
<pre><code class="language-toml">[[chains]]
id = 'ibc-0'
rpc_addr = 'tcp://localhost:26657'
grpc_addr = 'tcp://localhost:9090'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'
</code></pre>
<h3><a class="header" href="#light-clients" id="light-clients">Light clients</a></h3>
<p>The configuration file stores information about the light client peers. This configuration can be added to the configuration file when running the <code>relayer light add</code> command. Please see the <a href="./light_clients.html">Light Clients</a> section to learn how to configure them.</p>
<h3><a class="header" href="#adding-private-keys" id="adding-private-keys">Adding Private Keys</a></h3>
<p>For each chain configured you need to add a private key for that chain in order to submit <a href="./transactions.html">transactions</a>, please refer to the <a href="./keys.html">Keys</a> sections in order to learn how to add the private keys that are used by the relayer.</p>
<h3><a class="header" href="#example-configuration-file" id="example-configuration-file">Example configuration file</a></h3>
<p>Here is a full example of a configuration file with two chains configured and light client peers added:</p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'tcp://localhost:26657'
grpc_addr = 'tcp://localhost:9090'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[chains.peers]
primary = '66E3B7083DF9DD1FC57A611929BF4C505E34AA88'

[[chains.peers.light_clients]]
peer_id = '66E3B7083DF9DD1FC57A611929BF4C505E34AA88'
address = 'tcp://localhost:26657'
timeout = '10s'
trusted_header_hash = 'A24F654188BC3FC9EFE589FB33D513CE9AC86BFA48B063BDBF1D769750713E09'
trusted_height = '15'

[chains.peers.light_clients.store]
type = 'disk'
path = '/ibc-rs/data/ibc-0/data/66E3B7083DF9DD1FC57A611929BF4C505E34AA88'

[[chains.peers.light_clients]]
peer_id = '2427F8D914A6862279B3326FA64F76E3BC06DB2E'
address = 'tcp://localhost:26657'
timeout = '10s'
trusted_header_hash = '44E7C90BFA53256AD72B84286BFDA70FE87BBC7C0D80A1DB199C72A4FBE88FB6'
trusted_height = '16'

[chains.peers.light_clients.store]
type = 'disk'
path = '/ibc-rs/data/ibc-0/data/2427F8D914A6862279B3326FA64F76E3BC06DB2E'

[[chains]]
id = 'ibc-1'
rpc_addr = 'tcp://localhost:26557'
grpc_addr = 'tcp://localhost:9091'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[chains.peers]
primary = '28ED8856CBACA85DA866AB99F50DB22A58DA35F4'

[[chains.peers.light_clients]]
peer_id = '28ED8856CBACA85DA866AB99F50DB22A58DA35F4'
address = 'tcp://localhost:26557'
timeout = '10s'
trusted_header_hash = '66BD0E5ED1FA2022A036782F7D8444DB98DC0326B379BCA6BA75864295D1C910'
trusted_height = '4'

[chains.peers.light_clients.store]
type = 'disk'
path = '/ibc-rs/data/ibc-1/data/28ED8856CBACA85DA866AB99F50DB22A58DA35F4'

[[chains.peers.light_clients]]
peer_id = 'A885BB3D3DFF6101188B462466AE926E7A6CD51E'
address = 'tcp://localhost:26557'
timeout = '10s'
trusted_header_hash = '0325BFAA36407D1F11966AEC57D34131CB27B370D3698F284F09152ADE3423C4'
trusted_height = '5'

[chains.peers.light_clients.store]
type = 'disk'
path = '/ibc-rs/data/ibc-1/data/A885BB3D3DFF6101188B462466AE926E7A6CD51E'
</code></pre>
<h3><a class="header" href="#next-steps-2" id="next-steps-2">Next Steps</a></h3>
<p>Now that you learned how to build the relayer and how to create a configuration file, you can go to the <a href="./two_chains.html"><code>Two Chains</code></a> tutorial to learn how to perform some local testing connecting the relayer to two local chains.</p>
<h1><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h1>
<p>This section includes tutorials for some common relayer uses cases and commands. You can also refer to the <a href="./commands.html">Commands Reference</a> section to learn more about individual commands.</p>
<h2><a class="header" href="#basic-tutorials" id="basic-tutorials">Basic tutorials</a></h2>
<p><strong><a href="./two_chains.html">Two Local Chains</a></strong></p>
<p>In this tutorial you will learn how to start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and start relaying packets between them.</p>
<h1><a class="header" href="#tutorial-relayer-with-two-local-chains" id="tutorial-relayer-with-two-local-chains">Tutorial: Relayer with two local chains</a></h1>
<p>In this tutorial we will show how you can test the relayer against two chains, we provide a script that can start two separate chains and configure them automatically. This is the easiest way to get started.</p>
<p>The script starts two <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Follow the steps in this tutorial section starting with the <a href="./gaia.html">Install Gaia</a> section.</p>
<h1><a class="header" href="#install-gaia" id="install-gaia">Install Gaia</a></h1>
<p>The script to start the chains requires gaia to be installed.</p>
<blockquote>
<p><strong>NOTE</strong>: This assumes you have <code>Golang</code> programming language installed on 
your machine. If not, please ensure you install before proceeding. See 
more details in the <a href="pre_requisites.html#2-golang">Pre-requisites</a> section.</p>
</blockquote>
<h4><a class="header" href="#clone-gaia" id="clone-gaia">Clone gaia</a></h4>
<p>Clone the repository from Github:</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/gaia.git ~/go/src/github.com/cosmos/gaia
</code></pre>
<h4><a class="header" href="#build-and-install" id="build-and-install">Build and Install</a></h4>
<p>Run the <code>make</code> command to build and install <code>gaiad</code></p>
<pre><code class="language-shell">cd ~/go/src/github.com/cosmos/gaia
git checkout v4.0.0
make install
</code></pre>
<p>If the command above is successful you can run the following command to ensure it was properly installed:</p>
<pre><code class="language-shell">gaiad version
</code></pre>
<h2><a class="header" href="#next-steps-3" id="next-steps-3">Next Steps</a></h2>
<p>In the next section you will learn how to <a href="./local_chains.html">start two local chains</a></p>
<h1><a class="header" href="#start-the-local-chains" id="start-the-local-chains">Start the local chains</a></h1>
<p>To start the local chains, open a terminal and navigate to the <code>ibc-rs</code> repository folder</p>
<pre><code class="language-bash">cd ibc-rs
</code></pre>
<h3><a class="header" href="#stop-existing-gaiad-processes" id="stop-existing-gaiad-processes">Stop existing <code>gaiad</code> processes</a></h3>
<p>If this is not the first time you are running the script, you can manually stop the two gaia instances executing the following command to kill all <code>gaiad</code> processes:</p>
<pre><code class="language-shell">killall gaiad
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 26657 or port 9090), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<h3><a class="header" href="#configuration-file" id="configuration-file">Configuration file</a></h3>
<p>In order to run the script, you will need a <code>TOML</code> configuration file to be passed as a parameter. Please check the <a href="./config.html"><code>Configuration</code></a> section for more information about the relayer configuration file.</p>
<p>The following configuration file in the <code>ibc-rs</code> repository folder can be used for running the local chains:</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'tcp://localhost:26657'
grpc_addr = 'tcp://localhost:9090'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 3000000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'tcp://localhost:26557'
grpc_addr = 'tcp://localhost:9091'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 3000000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'
</code></pre>
<h4><a class="header" href="#saving-the-configuration-file" id="saving-the-configuration-file">Saving the configuration file</a></h4>
<h5><a class="header" href="#create-the-configtoml-file" id="create-the-configtoml-file">Create the config.toml file</a></h5>
<pre><code class="language-shell">mkdir -p $HOME/.hermes &amp;&amp; touch $HOME/.hermes/config.toml
</code></pre>
<h5><a class="header" href="#add-content-to-the-configuration-file" id="add-content-to-the-configuration-file">Add content to the configuration file:</a></h5>
<p>You can use your preferred text editor. If using <code>vi</code> you can run:</p>
<pre><code class="language-shell">vi ~/.hermes/config.toml
</code></pre>
<p>Then just <strong><code>copy</code></strong> the content for <code>config.toml</code> above and <strong><code>paste</code></strong> into this file.</p>
<h3><a class="header" href="#running-the-script-to-start-the-chains" id="running-the-script-to-start-the-chains">Running the script to start the chains</a></h3>
<p>From the <code>ibc-rs</code> repository folder run the following script with the parameters below to start the chains (<code>ibc-0</code> and <code>ibc-1</code>) and configure the light client peers:</p>
<pre><code class="language-bash">./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the script above prompts you to delete the data folder just answer <strong>'yes'</strong></p>
</blockquote>
<p>The script configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other <strong><code>ibc-1</code></strong></p>
<pre class="mermaid">graph TD
    A[dev-env] --&gt;|run| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| F[ibc-1]
</pre>
<p>If the script runs successfully you should see a message similar to the one below in the terminal:</p>
<pre><code class="language-shell">GAIA VERSION INFO: 4.0.0
Generating gaia configurations...
Creating gaiad instance: home=./data | chain-id=ibc-0 | p2p=:26656 | rpc=:26657 | profiling=:6060 | grpc=:9090 | samoleans=:100000000000
Change settings in config.toml file...
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Creating gaiad instance: home=./data | chain-id=ibc-1 | p2p=:26556 | rpc=:26557 | profiling=:6061 | grpc=:9091 | samoleans=:100000000000
Change settings in config.toml file...
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
ibc-0 initialized. Watch file /dev/github.com/informalsystems/ibc-rs/data/ibc-0.log to see its execution.
ibc-1 initialized. Watch file /dev/github.com/informalsystems/ibc-rs/data/ibc-1.log to see its execution.
Building the Rust relayer...
Removing light client peers from configuration...
Adding primary peers to light client configuration...
Adding secondary peers to light client configuration...
Importing keys...
Done!
</code></pre>
<h3><a class="header" href="#data-directory" id="data-directory">Data directory</a></h3>
<p>The script creates a <strong><code>data</code></strong> directory in the current directory in order. The <strong><code>data</code></strong> directory contains the chain stores and configuration files.</p>
<p>The <strong><code>data</code></strong> directory has a tree structure similar to the one below:</p>
<pre><code class="language-shell">data
├── ibc-0
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── key_seed.json
│   └── validator_seed.json
├── ibc-0.log
├── ibc-1
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── key_seed.json
│   └── validator_seed.json
└── ibc-1.log

</code></pre>
<h3><a class="header" href="#homehermes-directory" id="homehermes-directory">$HOME/.hermes directory</a></h3>
<p>By the default <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder. </p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="./keys.html">Keys</a> section. </p>
<p>After executing the <strong><code>dev-env</code></strong> script, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       └── testkey.json
    └── ibc-1
        └── keyring-test
            └── testkey.json
</code></pre>
<h4><a class="header" href="#next-steps-4" id="next-steps-4">Next Steps</a></h4>
<p>We now offer two options with regard to connecting the two chains:</p>
<ol>
<li>you can use <a href="./tutorial_raw.html">individual (raw) transactions</a> to create 
all the necessary chain objects (clients, connections, channels), or</li>
<li>you can perform this step using a 
<a href="./tutorial_relay_paths.html">simplified approach</a>.</li>
</ol>
<h1><a class="header" href="#connecting-the-chains" id="connecting-the-chains">Connecting the chains</a></h1>
<p>In the rest of this section we will show how to create the clients, establish a connection and a channel between the two chains, and relay packets over the channel. But first, a note on identifiers.</p>
<h2><a class="header" href="#identifiers" id="identifiers">Identifiers</a></h2>
<p>A chain allocates identifiers when it creates clients, connections and channels. These identifiers can subsequently be used to refer to existing clients, connections and channels.</p>
<p>Chains allocate identifiers using a chain specific allocation scheme.
Currently, cosmos-SDK implementation uses:</p>
<ul>
<li>
<p><code>07-tendermint-&lt;n&gt;</code> for tendermint clients</p>
<ul>
<li>For example <code>07-tendermin-0</code> is assigned to the first client created on <code>ibc-1</code>:
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;CreateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 44895,
        &quot;revision_number&quot;: 0
      },
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
We will create a second client on <code>ibc-1</code> with identifier <code>07-tendermint-1</code> in the client tutorial.</li>
</ul>
</li>
<li>
<p><code>connection-&lt;n&gt;</code> for connections</p>
<ul>
<li>For example <code>connection-0</code> is assigned to the first connection created on <code>ibc-1</code>:
<pre><code class="language-shell">hermes tx raw conn-init ibc-1 ibc-0 07-tendermint-0 07-tendermint-0 | jq
</code></pre>
<pre><code class="language-json">{
 &quot;status&quot;: &quot;success&quot;,
 &quot;result&quot;: {
   &quot;OpenInitConnection&quot;: {
     &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
     &quot;connection_id&quot;: &quot;connection-0&quot;,
     &quot;counterparty_client_id&quot;: &quot;07-tendermint-0&quot;,
     &quot;counterparty_connection_id&quot;: null,
     &quot;height&quot;: &quot;1&quot;
   }
 }
}
</code></pre>
We will create a second connection on <code>ibc-1</code> with identifier <code>connection-1</code> in the connection tutorial.</li>
</ul>
</li>
<li>
<p><code>channel-&lt;n&gt;</code> for channels</p>
<ul>
<li>For example <code>channel-0</code> is assigned to the first channel created on <code>ibc-1</code>:
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-1 ibc-0 connection-0 transfer transfer | jq
</code></pre>
<pre><code class="language-json">{
&quot;status&quot;: &quot;success&quot;,
&quot;result&quot;: {
  &quot;OpenInitChannel&quot;: {
    &quot;channel_id&quot;: &quot;channel-2&quot;,
    &quot;connection_id&quot;: &quot;connection-0&quot;,
    &quot;counterparty_channel_id&quot;: null,
    &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
    &quot;height&quot;: &quot;1&quot;,
    &quot;port_id&quot;: &quot;transfer&quot;
  }
}
}
</code></pre>
We will create a second channel on <code>ibc-1</code> with identifier <code>channel-1</code> in the channel tutorial.</li>
</ul>
</li>
</ul>
<p>In the following tutorials the <code>ibc-0</code> and <code>ibc-1</code> chains are setup and configured. For clarity, the tutorials run on a setup where the identifiers allocated to the client, connection and channel on <code>ibc-0</code> are <code>07-tendermint-0</code>, <code>connection-0</code> and <code>channel-0</code> respectively. Identifiers allocated to the client, connection and channel on <code>ibc-1</code> are <code>07-tendermint-1</code>, <code>connection-1</code> and <code>channel-1</code> respectively.</p>
<p>If you want to ensure you get the same identifiers while following the tutorial, run the above three commands once on <code>ibc-1</code> before going over the next sections.</p>
<h2><a class="header" href="#steps-to-start-relaying-packets-between-the-two-local-chains" id="steps-to-start-relaying-packets-between-the-two-local-chains">Steps to start relaying packets between the two local chains</a></h2>
<p>In order to start relaying packets please follow the steps below:</p>
<ul>
<li>
<p><a href="./tutorial_client_raw.html">Configure Clients</a></p>
</li>
<li>
<p><a href="./tutorial_conn_raw.html">Connection Handshake</a></p>
</li>
<li>
<p><a href="./tutorial_chan_open_raw.html">Open the Channel</a></p>
</li>
<li>
<p><a href="tutorial_packet_raw.html">Relay Packets</a></p>
</li>
</ul>
<h1><a class="header" href="#1-configuring-clients" id="1-configuring-clients">1. Configuring clients</a></h1>
<h3><a class="header" href="#11-create-client" id="11-create-client">1.1. <code>create client</code></a></h3>
<p>First you will need to create a client for each chain:</p>
<p>This command submits a transaction to a destination chain (<code>ibc-0</code>) with a request to create a client for a source chain (<code>ibc-1</code>):</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1
</code></pre>
<p>if the command is successful a message similar to the one below will be displayed <code>status:success</code>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;success&quot;,
    &quot;result&quot;: [
        {
            &quot;CreateClient&quot;: {
                &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
                &quot;client_type&quot;: &quot;Tendermint&quot;,
                &quot;consensus_height&quot;: {
                    &quot;revision_height&quot;: 9082,
                    &quot;revision_number&quot;: 1
                },
                &quot;height&quot;: &quot;1&quot;
            }
        }
    ]
}
</code></pre>
<blockquote>
<p>Please note the <code>client_id</code> value returned. You will need that for other commands.</p>
</blockquote>
<p>You can also execute a <strong>query</strong> to view the client state on destination chain <code>ibc-0</code> by specifying the <code>client_id</code> value <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-0 07-tendermint-0
</code></pre>
<p>which show a message similar to the one below:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;type&quot;: &quot;Tendermint&quot;,
    &quot;allow_update_after_expiry&quot;: false,
    &quot;allow_update_after_misbehaviour&quot;: false,
    &quot;chain_id&quot;: &quot;ibc-1&quot;,
    &quot;frozen_height&quot;: {
      &quot;revision_height&quot;: 0,
      &quot;revision_number&quot;: 0
    },
    &quot;latest_height&quot;: {
      &quot;revision_height&quot;: 9082,
      &quot;revision_number&quot;: 1
    },
    &quot;max_clock_drift&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 3
    },
    &quot;trust_level&quot;: {
      &quot;denominator&quot;: &quot;3&quot;,
      &quot;numerator&quot;: &quot;1&quot;
    },
    &quot;trusting_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1209600
    },
    &quot;unbonding_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1814400
    },
    &quot;upgrade_path&quot;: [
      &quot;upgrade&quot;,
      &quot;upgradedIBCState&quot;
    ]
  }
}
</code></pre>
<p>Now let's do the same for <code>ibc-1</code> as the destination chain:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0
</code></pre>
<p>Take note of the <code>client_id</code> allocated for this client. In the examples we assume is <code>07-tendermint-1</code>.</p>
<p>As before, if the command is successful a message with <code>status:success</code> is displayed:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;success&quot;,
    &quot;result&quot;: {
        &quot;CreateClient&quot;: {
            &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
            &quot;client_type&quot;: &quot;Tendermint&quot;,
            &quot;consensus_height&quot;: {
                &quot;revision_height&quot;: 9505,
                &quot;revision_number&quot;: 0
            },
            &quot;height&quot;: &quot;1&quot;
        }
    }
}
</code></pre>
<h3><a class="header" href="#12-update-client" id="12-update-client">1.2 <code>update-client</code></a></h3>
<p>Client states can be updated by sending an <code>update-client</code> transaction:</p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 ibc-1 07-tendermint-0
</code></pre>
<pre><code class="language-shell">hermes tx raw update-client ibc-1 ibc-0 07-tendermint-1
</code></pre>
<h2><a class="header" href="#next-steps-5" id="next-steps-5">Next Steps</a></h2>
<p>In the next section, we'll establish the <a href="./tutorial_conn_raw.html">Connection Handshake</a></p>
<h1><a class="header" href="#2-connection-handshake" id="2-connection-handshake">2. Connection Handshake</a></h1>
<h3><a class="header" href="#21-conn-init" id="21-conn-init">2.1 <code>conn-init</code></a></h3>
<p>Initialize a new connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-0</code> on <code>ibc-0</code> in order to use it in the <code>conn-try</code> command below.</p>
<h3><a class="header" href="#22-conn-try" id="22-conn-try">2.2 <code>conn-try</code></a></h3>
<p>Send a connection try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-0 07-tendermint-1 -s connection-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-1</code> on <code>ibc-1</code>. Use in the <code>conn-ack</code> CLI</p>
<h3><a class="header" href="#23-conn-ack" id="23-conn-ack">2.3 conn-ack</a></h3>
<p>Send a connection open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1
</code></pre>
<h3><a class="header" href="#24-conn-confirm" id="24-conn-confirm">2.4 conn-confirm</a></h3>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0
</code></pre>
<h3><a class="header" href="#25-query-connection" id="25-query-connection">2.5 query connection</a></h3>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1
</code></pre>
<pre><code class="language-shell">hermes query connection end ibc-0 connection-0
</code></pre>
<h2><a class="header" href="#next-steps-6" id="next-steps-6">Next Steps</a></h2>
<p>In the next section, we'll <a href="./tutorial_chan_open_raw.html">establish a new channel</a></p>
<h1><a class="header" href="#3-channel-handshake" id="3-channel-handshake">3. Channel Handshake</a></h1>
<h3><a class="header" href="#31-chan-open-init" id="31-chan-open-init">3.1 chan-open-init</a></h3>
<p>Initialize a new unordered channel on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer -o UNORDERED
</code></pre>
<h3><a class="header" href="#32-chan-open-try" id="32-chan-open-try">3.2 chan-open-try</a></h3>
<p>Send a channel open try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>channel-1</code> on <code>ibc-1</code>. Use in the <code>chan-open-ack</code> CLI</p>
<h3><a class="header" href="#33-chan-open-ack" id="33-chan-open-ack">3.3 chan-open-ack</a></h3>
<p>Send a channel open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<h3><a class="header" href="#34-chan-open-confirm" id="34-chan-open-confirm">3.4 chan-open-confirm</a></h3>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<h3><a class="header" href="#35-query-channel" id="35-query-channel">3.5 query channel</a></h3>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query channel end ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-shell">hermes query channel end ibc-1 transfer channel-1
</code></pre>
<h2><a class="header" href="#next-steps-7" id="next-steps-7">Next Steps</a></h2>
<p>In the next section, we'll start to <a href="./tutorial_packet_raw.html">relay packets</a></p>
<h1><a class="header" href="#4-relay-packets" id="4-relay-packets">4. Relay Packets</a></h1>
<h3><a class="header" href="#41-query-balances" id="41-query-balances">4.1 Query balances:</a></h3>
<ul>
<li>
<p>balance at ibc-0</p>
<pre><code class="language-shellscript">gaiad --node tcp://localhost:26657 query bank balances $(gaiad --home data/ibc-0 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
<li>
<p>balance at ibc-1</p>
<pre><code class="language-shellscript">gaiad --node tcp://localhost:26557 query bank balances $(gaiad --home data/ibc-1 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
</ul>
<blockquote>
<p>Note that the addresses used in the two commands above are configured in <code>dev-env</code>.</p>
</blockquote>
<h3><a class="header" href="#42-packet-relaying" id="42-packet-relaying">4.2 Packet relaying:</a></h3>
<p>First, we'll send <code>9999</code> <code>samoleans</code> from <code>ibc-0</code> to <code>ibc-1</code>.</p>
<ul>
<li>
<p>start the transfer of 9999 samoleans from <code>ibc-0</code> to <code>ibc-1</code>. This sends a <code>MsgTransfer</code> in a transaction to <code>ibc-0</code></p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>query packet commitments on <code>ibc-0</code></p>
<pre><code class="language-shellscript">hermes query packet commitments ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived packets on <code>ibc-1</code></p>
<pre><code class="language-shellscript">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>send recv_packet to <code>ibc-1</code></p>
<pre><code class="language-shellscript">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived acks on <code>ibc-0</code></p>
<pre><code class="language-shellscript">hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>send acknowledgement to <code>ibc-0</code></p>
<pre><code class="language-shellscript">hermes tx raw packet-ack  ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>send 1 packet with low timeout height offset to ibc-0</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 2 -n 1
</code></pre>
</li>
<li>
<p>send timeout to <code>ibc-0</code></p>
<pre><code class="language-shellscript">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
</ul>
<p>Send those samoleans back, from <code>ibc-1</code> to <code>ibc-1</code>.</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 1000 -n 1 -d ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199
hermes tx raw packet-recv ibc-0 ibc-1 transfer channel-1
hermes tx raw packet-ack  ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>The <code>ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199</code> denominator above can be obtained by querying the balance at <code>ibc-1</code> after the transfer from <code>ibc-0</code> to <code>ibc-1</code> is concluded.</p>
<h1><a class="header" href="#connect-the-chains-using-relay-paths" id="connect-the-chains-using-relay-paths">Connect the chains using relay paths</a></h1>
<p>A relay path refers to a specific channel used to interconnect two chains and over which packets are being sent.
Hermes can be started to listen for packet events on the two ends of a path and relay packets. This can be done over a new or existing path.</p>
<ul>
<li><a href="./tutorial_set_new_path.html">Create a new path</a></li>
<li><a href="./tutorial_relay_existing_path.html">Packet relaying on existing path</a></li>
<li><a href="./tutorial_relay_new_path.html">Packet relaying on new path</a></li>
</ul>
<h1><a class="header" href="#create-a-new-path" id="create-a-new-path">Create a new path</a></h1>
<p>Perform client creation, connection and channel handshake to establish a new path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> chains.</p>
<pre><code class="language-shellscript">hermes channel handshake ibc-0 ibc-1 transfer transfer
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;a_side&quot;: {
      &quot;chain&quot;: &quot;ibc-1&quot;,
      &quot;channel_id&quot;: &quot;channel-3&quot;,
      &quot;client_id&quot;: &quot;07-tendermint-3&quot;,
      &quot;connection_id&quot;: &quot;connection-2&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;},
    &quot;b_side&quot;: {
      &quot;chain&quot;: &quot;ibc-0&quot;,
      &quot;channel_id&quot;: &quot;channel-1&quot;,
      &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;connection_id&quot;: &quot;connection-3&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    },
    &quot;ordering&quot;:&quot;Unordered&quot;
  }
}
</code></pre>
<h1><a class="header" href="#packet-relaying-on-existing-path" id="packet-relaying-on-existing-path">Packet relaying on existing path</a></h1>
<p>Hermes can listen to IBC packet events over a specified path and relay receive packets, acknowledgments and timeouts.</p>
<ol>
<li>
<p>From one terminal start hermes using the <code>start</code> command and specify the port and a previously established channel:</p>
<pre><code class="language-shellscript">hermes start ibc-0 ibc-1 transfer channel-0
</code></pre>
<blockquote>
<p>In this example, the channel identifier on <code>ibc-0</code>is <code>channel-0</code> while the identifier on<code>ibc-1</code> is <code>channel-1</code></p>
</blockquote>
</li>
<li>
<p>In a separate terminal, use the transfer command to send 2 packets to <code>ibc0</code> chain:</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>Use the CLI to send 2 packets to <code>ibc1</code> chain:</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-1 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and the <code>recv_packet</code> -s are sent out.</p>
</li>
<li>
<p>Query the unreceived packets on <code>ibc0</code> and <code>ibc1</code> from a different terminal</p>
<pre><code class="language-shellscript">hermes query packet unreceived-packets ibc-1 ibc-0  transfer channel-0
hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-packets ibc-0 ibc-1  transfer channel-1
hermes query packet unreceived-acks ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>There should be no unreceived packets and acks:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: []
}
</code></pre>
<blockquote>
<p>It may also show packets that have been sent before the relayer loop was started (Hermes currently does not flush those).</p>
</blockquote>
</li>
</ol>
<h2><a class="header" href="#packet-relaying-on-new-path" id="packet-relaying-on-new-path">Packet relaying on new path</a></h2>
<p>Hermes packet relaying can be done over a newly established path. It performs client creation, connection and channel handshake if a relay path is present in the configuration file.</p>
<ol>
<li>
<p>Specify the path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> by including the following in the configuration file:</p>
<pre><code class="language-toml">[[connections]]
a_chain = &quot;ibc1&quot;
b_chain = &quot;ibc0&quot;

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'
</code></pre>
</li>
<li>
<p>From one terminal start hermes over this path:</p>
<pre><code class="language-shellscript">hermes start ibc-0 ibc-1
</code></pre>
<blockquote>
<p>The different modes of operations are currently under heavy development. In this release the fist path specified between two chains is selected.</p>
</blockquote>
<p>Once the path is established the relayer waits listening for IBC packet events.</p>
</li>
<li>
<p>in a separate terminal, use the transfer command to send 2 packets to <code>ibc0</code> chain:</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>use the CLI to send 2 packets to <code>ibc1</code> chain:</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-1 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and the <code>recv_packet</code> -s are sent out.</p>
</li>
<li>
<p>Query the unreceived packets on <code>ibc0</code> and <code>ibc1</code> from a different terminal</p>
<pre><code class="language-shellscript">hermes query packet unreceived-packets ibc-1 ibc-0  transfer channel-0
hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1
hermes query packet unreceived-packets ibc-0 ibc-1  transfer channel-1
hermes query packet unreceived-acks ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>There should be no unreceived packets and acks:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: []
}
</code></pre>
<blockquote>
<p>It may also show packets that have been sent before the relayer loop was started (Hermes currently does not flush those).</p>
</blockquote>
</li>
</ol>
<h1><a class="header" href="#concurrent-packet-relaying-on-multiple-paths" id="concurrent-packet-relaying-on-multiple-paths">Concurrent packet relaying on multiple paths</a></h1>
<p>At the moment, one Hermes instance relays packets over a single channel.
To relay packets over multiple channels, one needs to spawn multiple instances.</p>
<blockquote>
<p>Due to a current limitation, an instance needs its own configuration file
and its own <code>data</code> folder. The steps below describe the process for setting things
up properly for two hermes instances.</p>
</blockquote>
<ol>
<li>
<p>From the <code>ibc-rs</code> repository folder run the following script with the parameters below to start the chains (<code>ibc-0</code> and <code>ibc-1</code>):</p>
<pre><code class="language-bash">./scripts/setup-chains ibc-0 ibc-1
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the script above prompts you to delete the data folder just answer <strong>'yes'</strong></p>
</blockquote>
<p>The script configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other <strong><code>ibc-1</code></strong></p>
</li>
<li>
<p>From the root of the working copy of <code>ibc-rs</code>, create a folder for the first instance:</p>
<pre><code class="language-shell">mkdir relay_a &amp;&amp; cd relay_a
</code></pre>
</li>
<li>
<p>Paste the following configuration in a file named <code>config.toml</code> in the <code>relay_a</code> directory:</p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'tcp://localhost:26657'
grpc_addr = 'tcp://localhost:9090'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'tcp://localhost:26557'
grpc_addr = 'tcp://localhost:9091'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[connections]]
a_chain = &quot;ibc-1&quot;
b_chain = &quot;ibc-0&quot;

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'
</code></pre>
</li>
<li>
<p>Create the data folders for both chains:</p>
<pre><code class="language-shell">mkdir -p data/ibc-0/data
mkdir -p data/ibc-1/data
</code></pre>
</li>
<li>
<p>Copy the keys over from the chains <code>data</code> directory:</p>
<pre><code class="language-shell">cp ../data/ibc-0/key_seed.json data/ibc-0/
cp ../data/ibc-1/key_seed.json data/ibc-1/
</code></pre>
</li>
<li>
<p>Initialize the light clients:</p>
<pre><code class="language-shell">../scripts/init-clients config.toml ibc-0 ibc-1
</code></pre>
</li>
<li>
<p>Let's proceed similarly for the second instance, but pay attention to the commands
and the configuration, as both are slightly different from the steps above.</p>
<p>From the root of the working copy of <code>ibc-rs</code>, create a folder for the second instance:</p>
<pre><code class="language-shell">mkdir relay_b &amp;&amp; cd relay_b
</code></pre>
</li>
<li>
<p>Paste the following configuration in a file named <code>config.toml</code> in the <code>relay_b</code> directory:</p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'error'

[[chains]]
id = 'ibc-0'
rpc_addr = 'tcp://localhost:26657'
grpc_addr = 'tcp://localhost:9090'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[chains]]
id = 'ibc-1'
rpc_addr = 'tcp://localhost:26557'
grpc_addr = 'tcp://localhost:9091'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
gas = 200000
clock_drift = '5s'
trusting_period = '14days'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[[connections]]
a_chain = &quot;ibc-0&quot;
b_chain = &quot;ibc-1&quot;

[[connections.paths]]
a_port = 'transfer'
b_port = 'transfer'
</code></pre>
</li>
<li>
<p>Create the data folders for both chains:</p>
<pre><code class="language-shell">mkdir -p data/ibc-0/data
mkdir -p data/ibc-1/data
</code></pre>
</li>
<li>
<p>Copy the keys over from the chains <code>data</code> directory:</p>
<pre><code class="language-shell">cp ../data/ibc-0/key_seed.json data/ibc-0/
cp ../data/ibc-1/key_seed.json data/ibc-1/
</code></pre>
</li>
<li>
<p>Initialize the light clients:</p>
<pre><code class="language-shell">../scripts/init-clients config.toml ibc-0 ibc-1
</code></pre>
</li>
<li>
<p>Start the first relayer in the <code>relay_a</code> directory:</p>
<pre><code class="language-shell">hermes -c config.toml start ibc-0 ibc-1
</code></pre>
<p>Take note of the identifier of this first channel created between the two chains, e.g. <code>channel-0</code></p>
</li>
<li>
<p>In another terminal, start the second relayer from the <code>relay_b</code> directory:</p>
<pre><code class="language-shell">hermes -c config.toml start ibc-0 ibc-1
</code></pre>
</li>
<li>
<p>In yet another terminal, From the either the <code>relay_a</code> or <code>relay_b</code> directory, use the <code>tx raw ft-transfer</code> command to send 2 packets to the <code>ibc0</code> chain:</p>
<pre><code class="language-shell">hermes -c config.toml tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 1000 -n 2
</code></pre>
<p>Take note of the identifier of the second channel created between the two chains, e.g. <code>channel-1</code></p>
</li>
<li>
<p>In yet another terminal:
Use the <code>tx raw ft-transfer</code> command to send packets on the two channels:</p>
<pre><code class="language-shell">hermes -c relay_a/config.toml tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 1000 -n 2
hermes -c relay_b/config.toml tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 9999 1000 -n 2
</code></pre>
</li>
<li>
<p>Observe the output on both relayer terminals, verify that the send events are processed, and the <code>recv_packet</code> -s are sent out.</p>
</li>
<li>
<p>Query the unreceived packets on <code>ibc-0</code> and <code>ibc-1</code> for both channels:</p>
<pre><code class="language-shell"># verify that there are no pending packets on channe-0 in either direction
hermes -c relay_a/config.toml query packet unreceived-packets ibc-1 ibc-0 transfer channel-0
hermes -c relay_a/config.toml query packet unreceived-acks    ibc-0 ibc-1 transfer channel-0
hermes -c relay_a/config.toml query packet unreceived-packets ibc-0 ibc-1 transfer channel-0
hermes -c relay_a/config.toml query packet unreceived-acks    ibc-1 ibc-0 transfer channel-0
# verify that there are no pending packets on channe-1 in either direction
hermes -c relay_b/config.toml query packet unreceived-packets ibc-1 ibc-0 transfer channel-1
hermes -c relay_b/config.toml query packet unreceived-acks    ibc-0 ibc-1 transfer channel-1
hermes -c relay_b/config.toml query packet unreceived-packets ibc-0 ibc-1 transfer channel-1
hermes -c relay_b/config.toml query packet unreceived-acks    ibc-1 ibc-0 transfer channel-1
</code></pre>
<p>There should be no unreceived packets and acks on both channels:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: []
}
</code></pre>
<blockquote>
<p>The above commands may show some packets if any have been sent before the instances were started (Hermes currently does not flush those).</p>
</blockquote>
</li>
</ol>
<h1><a class="header" href="#commands" id="commands">Commands</a></h1>
<p>The <code>Commands</code> section presents the commands current available in Hermes</p>
<h2><a class="header" href="#sections-2" id="sections-2">Sections</a></h2>
<p><strong><a href="./keys.html">Keys</a></strong></p>
<p>Commands to manage keys (private keys) for each chain.</p>
<p><strong><a href="./light_clients.html">Light Clients</a></strong></p>
<p>Commands to manage light client configuration. Allows adding and removing light client peers.</p>
<p><strong><a href="./relayer_loop.html">Path Setup and Streaming</a></strong></p>
<p>Commands to manage channels</p>
<p><strong><a href="./transactions.html">Raw Transactions</a></strong></p>
<p>Command to submit transactions to configured chains</p>
<p><strong><a href="./queries.html">Queries</a></strong></p>
<p>Commands to execute queries on configured chains</p>
<p><strong><a href="./listen.html">Listen Mode</a></strong></p>
<p>Commands to listen for IBC events</p>
<h1><a class="header" href="#adding-keys-to-the-relayer" id="adding-keys-to-the-relayer">Adding Keys to the Relayer</a></h1>
<p>Using the <code>keys</code> command you can add and list keys. </p>
<h4><a class="header" href="#show-usage" id="show-usage">Show usage</a></h4>
<p>To see the available sub-commands for the <code>keys</code> command run:</p>
<pre><code class="language-shell">hermes help keys
</code></pre>
<p>Currently there are two sub-commands supported <code>add</code> and <code>list</code>:</p>
<pre><code class="language-shell">USAGE:
    hermes-cli keys &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Manage keys in the relayer for each chain

SUBCOMMANDS:
    help       Get usage information
    add        adds a key to a configured chain
    list       list keys configured on a chain
</code></pre>
<h3><a class="header" href="#key-seed-file-private-key" id="key-seed-file-private-key">Key Seed file (Private Key)</a></h3>
<p>In order to execute the command below you need a private key file (JSON). The relayer uses the private key file to sign the transactions submitted to the chain.</p>
<p>The private key file can be obtained by using the <code>keys add</code> on a Cosmos chain, for example for a <code>gaia</code> chain the command is:</p>
<pre><code class="language-shell">gaiad keys add ...
</code></pre>
<p>The command outputs a JSON similar to the one below. You can save this file (e.g. key_seed.json) and use it to add to the relayer</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;user&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: Currently the relayer does NOT support a <code>keyring</code> store to securely store the private key file. The key file will be stored on the local file system in the user <strong>$HOME</strong> folder under <code>$HOME/.rrly</code></p>
</blockquote>
<h3><a class="header" href="#adding-keys" id="adding-keys">Adding Keys</a></h3>
<p>In order to add a key to a chain use the <code>keys add</code> command:</p>
<pre><code class="language-shell">USAGE:
    hermes keys add &lt;OPTIONS&gt;

DESCRIPTION:
    Adds a key to a configured chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain
    file                      the key path and filename

</code></pre>
<h4><a class="header" href="#add-a-private-key-to-a-chain" id="add-a-private-key-to-a-chain">Add a private key to a chain</a></h4>
<p>To add a private key file to a chain:</p>
<pre><code class="language-shell">hermes -c config keys add [CHAIN_ID] [PRIVATE_KEY_FILE]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">{&quot;status&quot;:&quot;success&quot;,&quot;result&quot;:[&quot;Added key testkey ([ADDRESS]) on [CHAIN ID] chain&quot;]}
</code></pre>
<h3><a class="header" href="#list-keys" id="list-keys">List keys</a></h3>
<p>In order to list the private keys added to chains use the <code>keys list</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys list &lt;OPTIONS&gt;

DESCRIPTION:
    List keys configured on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain
</code></pre>
<h4><a class="header" href="#listing-the-private-key-that-was-added-to-a-chain" id="listing-the-private-key-that-was-added-to-a-chain">Listing the private key that was added to a chain</a></h4>
<p>To list the private key file that was added to a chain:</p>
<pre><code class="language-shell">hermes -c config keys list [CHAIN_ID]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">{&quot;status&quot;:&quot;success&quot;,&quot;result&quot;:[&quot;chain: [CHAIN_ID] -&gt; testkey ([ADDRESS])&quot;]}
</code></pre>
<h1><a class="header" href="#light-clients-1" id="light-clients-1">Light Clients</a></h1>
<p>Using the <code>light</code> command you can add and remove light client peer information to the chain configuration.</p>
<h4><a class="header" href="#show-usage-1" id="show-usage-1">Show usage</a></h4>
<p>To see the available sub-commands for the <code>light</code> command run:</p>
<pre><code class="language-shell">hermes help light
</code></pre>
<p>There are two sub-commands supported <code>add</code> and <code>rm</code>:</p>
<pre><code class="language-shell">USAGE:
    hermes light &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Basic functionality for managing the lite clients

SUBCOMMANDS:
    add        add a light client peer for a given chain
    rm         remove a light client peer for a given chain

</code></pre>
<h3><a class="header" href="#adding-light-client-peers" id="adding-light-client-peers">Adding Light Client Peers</a></h3>
<p>In order to add the light client peers use the <code>add</code> command:</p>
<pre><code class="language-shell">USAGE:
    hermes light add &lt;OPTIONS&gt;

DESCRIPTION:
    Add a light client peer for a given chain

POSITIONAL ARGUMENTS:
    address                   RPC network address (required)

FLAGS:
    -c, --chain-id CHAIN-ID   identifier of the chain (required)
    -s, --store STORE         path to light client store for this peer (required)
    -p, --primary             whether this is the primary peer
    -f, --force               allow overriding an existing peer
    -y, --yes                 skip confirmation
    --peer-id PEER-ID         override peer id (optional)
    --height HEIGHT           override height (optional)
    --hash HASH               override hash (optional)
</code></pre>
<h4><a class="header" href="#set-the-primary-light-client-peer-for-a-chain" id="set-the-primary-light-client-peer-for-a-chain">Set the Primary Light Client Peer for a Chain</a></h4>
<p>In order to add a light client primary peer for a given chain execute the following command:</p>
<pre><code class="language-shell">hermes -c [CONFIG_FILE] light add tcp://[RPC_NETWORK_ADDRESS] -c [CHAIN_ID] -s [CHAIN_STORE] -p -y -f
</code></pre>
<h4><a class="header" href="#set-the-secondary-light-client-peer-for-a-chain" id="set-the-secondary-light-client-peer-for-a-chain">Set the Secondary Light Client Peer for a Chain</a></h4>
<p>In order to add a light client secondary peer for a given chain execute the following command:</p>
<pre><code class="language-shell">hermes -c [CONFIG_FILE] light add tcp://[RPC_NETWORK_ADDRESS] -c [CHAIN_ID] -s [CHAIN_STORE] --peer-id 17D46D8C1576A79203A6733F63B2C9B7235DD559 -y
</code></pre>
<blockquote>
<p>The <code>peer-id</code> above can be any valid value for a peer id. Currently, the relayer does not validate if this secondary peer exists.</p>
</blockquote>
<h3><a class="header" href="#removing-light-client-peers" id="removing-light-client-peers">Removing Light Client Peers</a></h3>
<p>In order to remove a light client peer use the <code>rm</code> command:</p>
<pre><code class="language-shell">USAGE:
    hermes light rm &lt;OPTIONS&gt;

DESCRIPTION:
    Remove a light client peer for a given chain

POSITIONAL ARGUMENTS:
    peer_id                   identifiers of peers to remove

FLAGS:
    -c, --chain-id CHAIN-ID   identifier of the chain to remove peers from
    -f, --force               force removal of primary peer
    --all                     remove all peers, implies --force
    -y, --yes                 skip confirmation

</code></pre>
<h4><a class="header" href="#removing-all-light-client-peers-from-a-chain" id="removing-all-light-client-peers-from-a-chain">Removing all light client peers from a chain</a></h4>
<p>In order to remove all light peers for a chain from the configuration execute the following command:</p>
<pre><code class="language-shell">hermes -c [CONFIG_FILE] light rm -c [CHAIN_ID] -y --all
</code></pre>
<h1><a class="header" href="#relay-path-setup-and-packet-streaming" id="relay-path-setup-and-packet-streaming">Relay Path Setup and Packet Streaming</a></h1>
<p>The <code>start</code> command can be used to send packet transactions triggered by IBC packet events that occur for a given channel. This is also referred to packet streaming.
A new channel can be established or an existing one can be specified.</p>
<pre><code class="language-shellscript">USAGE:
    hermes start &lt;OPTIONS&gt;

DESCRIPTION:
    start the relayer (currently this refers to the v0 relayer)

POSITIONAL ARGUMENTS:
    src_chain_id              identifier of the source chain
    dst_chain_id              identifier of the destination chain

FLAGS:
    -p, --src-port-id SRC-PORT-ID
    -c, --src-channel-id SRC-CHANNEL-ID
</code></pre>
<h2><a class="header" href="#start-with-new-channel" id="start-with-new-channel">Start with New Channel</a></h2>
<p>Use the <code>start</code> command without flags to create new clients on <code>source</code> and <code>destination</code> chains, and new connection and new channel between the two chains.</p>
<blockquote>
<p>Reusing existing clients or connection is not possible with the current version. The port used by the channel is obtained from and must be specified in the configuration file.</p>
</blockquote>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<pre><code class="language-shellscript">hermes start ibc-0 ibc-1
</code></pre>
<p>The relayer creates a new client on each chain and then established a new connection and a new channel using that connection. After that is enters a listen loop acting on packet events that occur on that channel.</p>
<h2><a class="header" href="#start-on-existing-channel" id="start-on-existing-channel">Start on Existing Channel</a></h2>
<p>Use the <code>start</code> command and specify the source port and channel identifier of a channel that is already created and in open state on both chains.</p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<pre><code class="language-shellscript">hermes start ibc-0 ibc-1 -p transfer -c channel-0
</code></pre>
<blockquote>
<p>Finishing uncompleted handshakes can only be achieved using the <code>tx raw</code> CLIs.</p>
</blockquote>
<h2><a class="header" href="#packet-streaming" id="packet-streaming">Packet Streaming</a></h2>
<p>After the relayer is started using the <code>start</code> command, it listens to IBC packet events for the channel. Assuming the events are coming from a <code>source</code> chain, the relayer builds packets based on these events, packets that are then sent either to the <code>source</code> chain or the counterparty (<code>destination</code>) chain. </p>
<p>Current events and actions are:</p>
<ul>
<li><code>send_packet</code>: the relayer builds a packet message with the <code>packet</code> obtained from the event and any required proofs obtained from the counterparty of the chain where the message is sent. The concrete packet is:
<ul>
<li><code>MsgRecvPacket</code>, sent to <code>destination</code> chain if the channel is in open state on the <code>destination</code> chain, and a timeout has not occurred,</li>
<li><code>MsgTimeout</code>, sent to the <code>source</code> chain if the channel is in open state on the <code>destination</code> chain, but a timeout has occurred.</li>
<li><code>MsgTimeoutOnClose</code>, sent to the <code>source</code> chain if the channel is in closed state on the <code>destination</code> chain.</li>
</ul>
</li>
<li><code>write_acknowledgement</code>: the relayer builds a <code>MsgAcknowledgement</code> packet that is sent to the <code>destination</code> chain.</li>
</ul>
<h2><a class="header" href="#relay-path-setup" id="relay-path-setup">Relay Path Setup</a></h2>
<p>The <code>channel handshake</code> command can be used to establish a new channel that uses a new connection and new clients. There is no requirement for the ports to be configured in the configuration file (i.e. its <code>connections</code> section may be missing).</p>
<blockquote>
<p>Reuse of existing clients and/or connections is not supported in the current version.</p>
</blockquote>
<pre><code class="language-shellscript">USAGE:
    hermes channel handshake &lt;OPTIONS&gt;

DESCRIPTION:
    tx raw

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -o, --ordering ORDERING   the channel order
</code></pre>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<pre><code class="language-shellscript">hermes channel handshake ibc-0 ibc-1 transfer transfer
</code></pre>
<h1><a class="header" href="#raw-transactions" id="raw-transactions">Raw Transactions</a></h1>
<p>There are a number of simple commands that perform minimal validation, build and send IBC transactions.</p>
<p>The <code>tx raw</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create-client</code></td><td><a href="./tx_client.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update-client</code></td><td><a href="./tx_client.html#update-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>conn-init</code></td><td><a href="./tx_connection.html#connection-init">Initialize a connection (ConnectionOpenInit)</a></td></tr>
<tr><td><code>conn-try</code></td><td><a href="./tx_connection.html#connection-try">Relay the connection attempt (ConnectionOpenTry)</a></td></tr>
<tr><td><code>conn-ack</code></td><td><a href="./tx_connection.html#connection-ack">Relay acknowledgment of a connection attempt (ConnectionOpenAck)</a></td></tr>
<tr><td><code>conn-confirm</code></td><td><a href="./tx_connection.html#connection-confirm">Confirm opening of a connection (ConnectionOpenConfirm)</a></td></tr>
<tr><td><code>chan-open-init</code></td><td><a href="./tx_channel_open.html#channel-open-init">Initialize a channel (ChannelOpenInit)</a></td></tr>
<tr><td><code>chan-open-try</code></td><td><a href="./tx_channel_open.html#channel-open-try">Relay the channel attempt (ChannelOpenTry)</a></td></tr>
<tr><td><code>chan-open-ack</code></td><td><a href="./tx_channel_open.html#channel-open-ack">Relay acknowledgment of a channel attempt (ChannelOpenAck)</a></td></tr>
<tr><td><code>chan-open-close</code></td><td><a href="./tx_channel_open.html#channel-open-close">Confirm opening of a channel (ChannelOpenConfirm)</a></td></tr>
<tr><td><code>chan-close-init</code></td><td><a href="./tx_channel_close.html#channel-close-init">Initiate the closing of a channel (ChannelCloseInit)</a></td></tr>
<tr><td><code>chan-close-confirm</code></td><td><a href="./tx_channel_close.html#channel-close-confirm">Confirm the closing of a channel (ChannelCloseConfirm)</a></td></tr>
<tr><td><code>ft-transfer</code></td><td><a href="./tx_packet.html#fungible-token-transfer">Send a fungible token transfer test transaction (ICS20 MsgTransfer)</a></td></tr>
<tr><td><code>packet-recv</code></td><td><a href="./tx_packet.html#relay-receive-and-timeout-packets">Relay receive or timeout packets</a></td></tr>
<tr><td><code>packet-ack</code></td><td><a href="./tx_packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></td></tr>
</tbody></table>
<p>The main purpose of these commands is to support development and testing, and continuous integration. These CLIs take quite a few parameters and they are explained in the individual sub-sections.</p>
<p>At a high level, most commands follow this template:</p>
<pre><code class="language-shell">hermes tx raw &lt;ibc-datagram&gt; &lt;dst-chain-id&gt; &lt;src-chain-id&gt; [-d &lt;dst-obj-id&gt; -s &lt;src-obj-id&gt;]*
</code></pre>
<p>In the command template above:</p>
<ul>
<li>
<p><code>ibc-datagram</code> - identifies the &quot;main&quot; IBC message that is being sent, e.g. <code>conn-init</code>, <code>conn-try</code>, <code>chan-open-init</code>, etc. To ensure successful processing on the receiving chain, the majority of these commands build and send two messages: one <code>UpdateClient</code> message followed by the actual IBC message. These two messages are included in a single transaction. This is done for all IBC datagrams that include proofs collected from the source chain.</p>
<p>The messages that do not require proofs are:</p>
<ul>
<li><code>MsgCreateClient</code> (<code>create-client</code> command),</li>
<li><code>MsgConnectionOpenInit</code> (<code>conn-open-init</code> command),</li>
<li><code>MsgChannelOpenInit</code> (<code>chan-open-init</code> command),</li>
<li><code>MsgChannelCloseInit</code> (<code>chan-close-init</code> command) and</li>
<li><code>MsgTransfer</code> (<code>ft-transfer</code> command)</li>
</ul>
</li>
<li>
<p><code>dst-chain-id</code> - is the identifier of the chain where the transaction will be sent.</p>
</li>
<li>
<p><code>src-chain-id</code> - is the identifier of the chain that is queried for the data that is included in the transaction, e.g. connection data, client proofs, etc. To ensure correct on-chain state, the relayer also queries the destination chain, however it does not include this information in the Tx to the destination chain.</p>
</li>
<li>
<p><code>dst-obj-id</code> - the identifier of an object on destination chain required by the datagram, e.g. the <code>client-id</code> associated with the connection on destination chain in connection datagrams. Or the <code>connection-id</code> in a <code>ConnOpenAck</code> datagram.</p>
</li>
<li>
<p><code>src-obj-id</code> - the identifier of an object on the source chain, required by the datagram, e.d. the <code>client-id</code> of the connection on source chain.</p>
</li>
<li>
<p>More details about the <code>tx raw</code> commands can be found in the following sections:</p>
<ul>
<li><a href="./tx_client.html">Client</a></li>
<li><a href="./tx_connection.html">Connection</a></li>
<li><a href="./tx_channel_open.html">Channel Open</a></li>
<li><a href="./tx_channel_close.html">Channel Close</a></li>
<li><a href="./tx_packet.html">Packet</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<pre><code class="language-shellscript">USAGE:
    hermes tx raw &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Raw commands for sending transactions to a configured chain.

SUBCOMMANDS:
    help                Get usage information
    create-client       Create a client for source chain on destination chain
    update-client       Update the specified client on destination chain
    conn-init           Initialize a connection (ConnectionOpenInit)
    conn-try            Relay the connection attempt (ConnectionOpenTry)
    conn-ack            Relay acknowledgment of a connection attempt (ConnectionOpenAck)
    conn-confirm        Confirm opening of a connection (ConnectionOpenConfirm)
    chan-open-init      Initialize a channel (ChannelOpenInit)
    chan-open-try       Relay the channel attempt (ChannelOpenTry)
    chan-open-ack       Relay acknowledgment of a channel attempt (ChannelOpenAck)
    chan-open-confirm   Confirm opening of a channel (ChannelOpenConfirm)
    chan-close-init     Initiate the closing of a channel (ChannelCloseInit)
    chan-close-confirm  Confirm the closing of a channel (ChannelCloseConfirm)
    ft-transfer         Send a fungible token transfer test transaction (ICS20 MsgTransfer)
    packet-recv         Relay receive or timeout packets
    packet-ack          Relay acknowledgment packets
</code></pre>
<h1><a class="header" href="#client" id="client">Client</a></h1>
<p>The <code>tx raw</code> commands can be used to create and update the on-chain IBC clients.</p>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="tx_client.html#create-client">Create Client</a></li>
<li><a href="tx_client.html#update-client">Update Client</a></li>
</ul>
<h2><a class="header" href="#create-client" id="create-client">Create Client</a></h2>
<p>Use the <code>create-client</code> command to create a new client.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw create-client &lt;OPTIONS&gt;

DESCRIPTION:
    Create a client for source chain on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain

</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client of <code>ibc-1</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;CreateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 18,
        &quot;revision_number&quot;: 1
      },
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<p>A new client is created with identifier <code>07-tendermint-0</code></p>
<h2><a class="header" href="#update-client" id="update-client">Update Client</a></h2>
<p>Use the <code>update-client</code> command to update an existing client with a new consensus state.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw update-client &lt;OPTIONS&gt;

DESCRIPTION:
    Update the specified client on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the client to be updated on destination chain
</code></pre>
<p><strong>Example</strong></p>
<p>Update the client on <code>ibc-0</code> with latest header of <code>ibc-1</code></p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 ibc-1 07-tendermint-0  | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;UpdateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 273,
        &quot;revision_number&quot;: 1
      },
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<p>The client with identifier <code>07-tendermint-0</code> has been updated with the consensus state at height <code>1-273</code>.</p>
<h1><a class="header" href="#connection-handshake" id="connection-handshake">Connection Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a connection between two clients.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No connection
    A-&gt;&gt;B: ConnectionOpenInit
    Note over B: connection: connection-0
    Note over B: counterparty: none
    B-&gt;&gt;A: ConnectionOpenTry
    Note over A: connection: connection-1
    Note over A: counterparty: connection-0
    A-&gt;&gt;B: ConnectionOpenAck
    note over B: connection: connection-0
    note over B: counterparty: connection-1
    B-&gt;&gt;A: ConnectionOpenConfirm
    Note over A, B: Connection open
</pre>
</center>
<h2><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="tx_connection.html#connection-init">Connection Init</a></li>
<li><a href="tx_connection.html#connection-try">Connection Try</a></li>
<li><a href="tx_connection.html#connection-ack">Connection Ack</a></li>
<li><a href="tx_connection.html#connection-confirm">Connection Confirm</a></li>
</ul>
<h2><a class="header" href="#connection-init" id="connection-init">Connection Init</a></h2>
<p>Use the <code>conn-init</code> command to initialize a new connection on a chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a connection (ConnectionOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client
</code></pre>
<p><strong>Example</strong></p>
<p>Given that two clients were previously created with identifier <code>07-tendermint-0</code> on chain <code>ibc-0</code> and
identifier <code>07-tendermint-1</code> on chain <code>ibc-1</code>, we can initialize a connection between the two clients.</p>
<p>First, let's initialize the connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenInitConnection&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;counterparty_client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;counterparty_connection_id&quot;: null,
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<p>A new connection has been initialized on <code>ibc-0</code> with identifier <code>connection-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_connection_id</code> field is currently empty.</p>
</blockquote>
<h2><a class="header" href="#connection-try" id="connection-try">Connection Try</a></h2>
<p>Use the <code>conn-try</code> command to establish a counterparty to the connection on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the connection attempt (ConnectionOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>connection-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -s connection-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenTryConnection&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;connection_id&quot;: &quot;connection-1&quot;,
      &quot;counterparty_client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;counterparty_connection_id&quot;: &quot;connection-0&quot;,
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<p>A new connection has been created on <code>ibc-1</code> with identifier <code>connection-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> points to the connection on <code>ibc-0</code>.</p>
</blockquote>
<h2><a class="header" href="#connection-ack" id="connection-ack">Connection Ack</a></h2>
<p>Use the <code>conn-ack</code> command to acknowledge the connection on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a connection attempt (ConnectionOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the connection attempt:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenAckConnection&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;counterparty_client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;counterparty_connection_id&quot;: &quot;connection-1&quot;,
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> now points to the connection on <code>ibc-1</code>.</p>
</blockquote>
<h2><a class="header" href="#connection-confirm" id="connection-confirm">Connection Confirm</a></h2>
<p>Use the <code>conn-confirm</code> command to confirm that the connection has been acknowledged,
and finish the handshake, after which the connection is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a connection (ConnectionOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the connection attempt.</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenConfirmConnection&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;connection_id&quot;: &quot;connection-1&quot;,
      &quot;counterparty_client_id&quot;: &quot;07-tendermint-0&quot;,
      &quot;counterparty_connection_id&quot;: &quot;connection-0&quot;,
      &quot;height&quot;: &quot;1&quot;
    }
  }
}
</code></pre>
<p>We have now successfully established a connection between the two chains.</p>
<h1><a class="header" href="#channel-open-handshake" id="channel-open-handshake">Channel Open Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a channel for a given connection. Only <code>unordered</code> channels are currently supported.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No channel
    A-&gt;&gt;B: ChannelOpenInit
    Note over B: channel: channel-0
    Note over B: channel: counterparty: none
    B-&gt;&gt;A: ChannelOpenTry
    Note over A: channel: channel-1
    Note over A: channel: counterparty: channel-0
    A-&gt;&gt;B: ChannelOpenAck
    note over B: channel: channel-0
    note over B: counterparty: channel-1
    B-&gt;&gt;A: ChannelOpenConfirm
    Note over A, B: Channel open
</pre>
</center>
<h2><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="tx_channel_open.html#channel-open-init">Channel Open Init</a></li>
<li><a href="tx_channel_open.html#channel-open-try">Channel Open Try</a></li>
<li><a href="tx_channel_open.html#channel-open-ack">Channel Open Ack</a></li>
<li><a href="tx_channel_open.html#channel-open-confirm">Channel Open Confirm</a></li>
</ul>
<h2><a class="header" href="#channel-open-init" id="channel-open-init">Channel Open Init</a></h2>
<p>Use the <code>chan-open-init</code> command to initialize a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a channel (ChannelOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -o, --ordering ORDERING   the channel order: `UNORDERED` or `ORDERED`, default `UNORDERED`
</code></pre>
<p><strong>Example</strong></p>
<p>First, let's initialize the channel on <code>ibc-0</code> using an existing connection identified by <code>connection-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenInitChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-0&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;counterparty_channel_id&quot;: null,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<p>A new channel has been initialized on <code>ibc-1</code> with identifier <code>channel-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_channel_id</code> field is currently empty.</p>
</blockquote>
<h2><a class="header" href="#channel-open-try" id="channel-open-try">Channel Open Try</a></h2>
<p>Use the <code>chan-open-try</code> command to establish a counterparty to the channel on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the channel attempt (ChannelOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>channel-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenTryChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-1&quot;,
      &quot;connection_id&quot;: &quot;connection-1&quot;,
      &quot;counterparty_channel_id&quot;: &quot;channel-0&quot;,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<p>A new channel has been created on <code>ibc-1</code> with identifier <code>channel-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> points to the channel on <code>ibc-0</code>.</p>
</blockquote>
<h2><a class="header" href="#channel-open-ack" id="channel-open-ack">Channel Open Ack</a></h2>
<p>Use the <code>chan-open-ack</code> command to acknowledge the channel on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a channel attempt (ChannelOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the opening of the channel:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenAckChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-0&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;counterparty_channel_id&quot;: &quot;channel-1&quot;,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> now points to the channel on <code>ibc-1</code>.</p>
</blockquote>
<h2><a class="header" href="#channel-open-confirm" id="channel-open-confirm">Channel Open Confirm</a></h2>
<p>Use the <code>chan-open-confirm</code> command to confirm that the channel has been acknowledged,
and finish the handshake, after which the channel is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a channel (ChannelOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the opening of the channel,
after which the channel is open on both chains.</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer channel-1 channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;OpenConfirmChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-1&quot;,
      &quot;connection_id&quot;: &quot;connection-1&quot;,
      &quot;counterparty_channel_id&quot;: &quot;channel-0&quot;,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<p>We have now successfully opened a channel over an existing connection between the two chains.</p>
<h1><a class="header" href="#channel-close-handshake" id="channel-close-handshake">Channel Close Handshake</a></h1>
<p>The channel close handshake involves two steps: init and confirm.</p>
<h2><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="tx_channel_close.html#channel-close-init">Channel Close Init</a></li>
<li><a href="tx_channel_close.html#channel-close-confirm">Channel Close Confirm</a></li>
</ul>
<h2><a class="header" href="#channel-close-init" id="channel-close-init">Channel Close Init</a></h2>
<p>Use the <code>chan-close-init</code> command to initialize the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initiate the closing of a channel (ChannelCloseInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;CloseInitChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-0&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;counterparty_channel_id&quot;: &quot;channel-1&quot;,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<h2><a class="header" href="#channel-close-confirm" id="channel-close-confirm">Channel Close Confirm</a></h2>
<p>Use the <code>chan-close-confirm</code> command to confirm the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm the closing of a channel (ChannelCloseConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;CloseConfirmChannel&quot;: {
      &quot;channel_id&quot;: &quot;channel-1&quot;,
      &quot;connection_id&quot;: &quot;connection-1&quot;,
      &quot;counterparty_channel_id&quot;: &quot;channel-0&quot;,
      &quot;counterparty_port_id&quot;: &quot;transfer&quot;,
      &quot;height&quot;: &quot;1&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    }
  }
}
</code></pre>
<p><strong>NOTE</strong>: The cosmos-sdk implementation does not allow the relayer to initiate the closing of channels.
Therefore, when using the Gaia release image, the <code>chan-close-init</code> command will
fail as the <code>cosmos-sdk</code> transfer module will reject the <code>MsgChannelCloseInit</code> message included in the transaction.
To be able to test channel closure, you will need to <a href="./help.html#patching-gaia">patch</a> your gaia deployments.</p>
<h1><a class="header" href="#packet-tx-commands" id="packet-tx-commands">Packet Tx Commands</a></h1>
<h2><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="tx_packet.html#fungible-token-transfer">Fungible token transfer</a></li>
<li><a href="tx_packet.html#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></li>
<li><a href="tx_packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></li>
</ul>
<h2><a class="header" href="#fungible-token-transfer" id="fungible-token-transfer">Fungible token transfer</a></h2>
<p>Use the <code>tx raw ft-transfer</code> command to send ICS-20 fungible token transfer packets.
<strong>NOTE:</strong> This command is mainly used for testing the packet features of the relayer.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw ft-transfer &lt;OPTIONS&gt;

DESCRIPTION:
    Send a fungible token transfer test transaction (ICS20 MsgTransfer)

POSITIONAL ARGUMENTS:
    src_chain_id              identifier of the source chain
    dest_chain_id             identifier of the destination chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
    amount                    amount of coins (samoleans, by default) to send (e.g. `100000`)
    height_offset             timeout in number of blocks since current

FLAGS:
    -d, --denom DENOM         denomination of the coins to send
    -n, --number-msgs NUMBER-MSGS
</code></pre>
<p><strong>Example</strong></p>
<p>Send two transfer packets from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer if for <code>9999</code> samoleans (default denomination) and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the relayer account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-0 9999 10 -n 2 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    {
      &quot;SendPacketChannel&quot;: {
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;7B22616...&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 7,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    },
    {
      &quot;SendPacketChannel&quot;: {
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;7B22616...&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 8,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    }
  ]
}
</code></pre>
<p>The transfer packets are stored on <code>ibc-0</code> and can be relayed.</p>
<h2><a class="header" href="#relay-receive-and-timeout-packets" id="relay-receive-and-timeout-packets">Relay receive and timeout packets</a></h2>
<p>Use the <code>tx raw packet-recv</code> command to relay the packets sent but not yet received. If the sent packets have timed out then a timeout packet is sent to the source chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-recv &lt;OPTIONS&gt;

DESCRIPTION:
    Relay receive or timeout packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the two transfer packets to the <code>ibc-1</code> module bound to the <code>transfer</code> port and the <code>channel-0</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the receive messages.</p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    {
      &quot;UpdateClient&quot;: {
        &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
        &quot;client_type&quot;: &quot;Tendermint&quot;,
        &quot;consensus_height&quot;: {
          &quot;revision_height&quot;: 25049,
          &quot;revision_number&quot;: 0
        },
        &quot;height&quot;: &quot;1&quot;
      }
    },
    {
      &quot;WriteAcknowledgementChannel&quot;: {
        &quot;ack&quot;: &quot;7B22726573756C74223A2241513D3D227D&quot;,
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;7B22616...&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 7,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    },
    {
      &quot;WriteAcknowledgementChannel&quot;: {
        &quot;ack&quot;: &quot;7B22726573756C74223A2241513D3D227D&quot;,
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;7B22616...&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 8,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    }
  ]
}
</code></pre>
<p>Both packets have been relayed to <code>ibc-1</code> and acknowledged.</p>
<h2><a class="header" href="#relay-acknowledgment-packets" id="relay-acknowledgment-packets">Relay acknowledgment packets</a></h2>
<p>Use the <code>tx raw packet-ack</code> command to relay acknowledgments to the original source of the packets.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-recv &lt;OPTIONS&gt;

DESCRIPTION:
    Relay receive or timeout packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the acknowledgments to the <code>ibc-0</code> module bound to the <code>transfer</code> port and the <code>channel-1</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the acknowledgments.</p>
<pre><code class="language-shell">hermes tx raw packet-ack ibc-0 ibc-1 transfer channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    {
      &quot;UpdateClient&quot;: {
        &quot;client_id&quot;: &quot;07-tendermint-0&quot;,
        &quot;client_type&quot;: &quot;Tendermint&quot;,
        &quot;consensus_height&quot;: {
          &quot;revision_height&quot;: 25673,
          &quot;revision_number&quot;: 1
        },
        &quot;height&quot;: &quot;1&quot;
      }
    },
    {
      &quot;AcknowledgePacketChannel&quot;: {
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 7,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    },
    {
      &quot;AcknowledgePacketChannel&quot;: {
        &quot;height&quot;: &quot;1&quot;,
        &quot;packet&quot;: {
          &quot;data&quot;: &quot;&quot;,
          &quot;destination_channel&quot;: &quot;channel-1&quot;,
          &quot;destination_port&quot;: &quot;transfer&quot;,
          &quot;sequence&quot;: 8,
          &quot;source_channel&quot;: &quot;channel-0&quot;,
          &quot;source_port&quot;: &quot;transfer&quot;,
          &quot;timeout_height&quot;: {
            &quot;revision_height&quot;: 25041,
            &quot;revision_number&quot;: 1
          },
          &quot;timeout_timestamp&quot;: 0
        }
      }
    }
  ]
}
</code></pre>
<p>Both acknowledgments have been received on <code>ibc-0</code>.</p>
<h1><a class="header" href="#queries" id="queries">Queries</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><a href="./query_client.html">Query information about clients</a></td></tr>
<tr><td><code>clients</code></td><td><a href="./query_client.html">Query all clients</a></td></tr>
<tr><td><code>connection</code></td><td><a href="./query_connection.html">Query information about connections</a></td></tr>
<tr><td><code>connections</code></td><td><a href="./query_connection.html">Query the identifiers of all connections on a chain</a></td></tr>
<tr><td><code>channel</code></td><td><a href="./query_channel.html">Query information about channels</a></td></tr>
<tr><td><code>channels</code></td><td><a href="./query_channel.html">Query the identifiers of all channels on a given chain</a></td></tr>
<tr><td><code>packet</code></td><td><a href="./query_packet.html">Query information about packets</a></td></tr>
</tbody></table>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<pre><code>USAGE:
    hermes query &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query objects from the chain

SUBCOMMANDS:
    client         Query information about clients
    clients        Query clients
    connection     Query information about connections
    connections    Query the identifiers of all connections on a chain
    channel        Query information about channels
    channels       Query the identifiers of all channels on a given chain
    packet         Query information about packets
</code></pre>
<h1><a class="header" href="#table-of-contents-5" id="table-of-contents-5">Table of Contents</a></h1>
<ul>
<li><a href="query_client.html#query-clients">Query Clients</a></li>
<li><a href="query_client.html#query-client-data">Query Client Data</a>
<ul>
<li><a href="query_client.html#query-the-client-state">Query the client state</a></li>
<li><a href="query_client.html#query-the-client-consensus-state">Query the client consensus state</a></li>
<li><a href="query_client.html#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-clients" id="query-clients">Query Clients</a></h1>
<p>Use the <code>query clients</code> command to query the identifiers of all clients on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query clients &lt;OPTIONS&gt;

DESCRIPTION:
    Query clients

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all clients on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query clients ibc-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;07-tendermint-0&quot;,
    &quot;07-tendermint-1&quot;,
    &quot;07-tendermint-2&quot;,
    &quot;07-tendermint-3&quot;
  ]
}
</code></pre>
<h1><a class="header" href="#query-client-data" id="query-client-data">Query Client Data</a></h1>
<p>Use the <code>query client</code> command to query the information about a specific client.</p>
<pre><code class="language-shell">USAGE:
    hermes query client &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about clients

SUBCOMMANDS:
    state      query client full state
    consensus  query client consensus
    connections query client connections
</code></pre>
<h2><a class="header" href="#query-the-client-state" id="query-the-client-state">Query the client state</a></h2>
<p>Use the <code>query client state</code> command to query the client state of a client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client state &lt;OPTIONS&gt;

DESCRIPTION:
    Query client full state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -h, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-1 07-tendermint-2 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;type&quot;: &quot;Tendermint&quot;,
    &quot;allow_update_after_expiry&quot;: false,
    &quot;allow_update_after_misbehaviour&quot;: false,
    &quot;chain_id&quot;: &quot;ibc-0&quot;,
    &quot;frozen_height&quot;: {
      &quot;revision_height&quot;: 0,
      &quot;revision_number&quot;: 0
    },
    &quot;latest_height&quot;: {
      &quot;revision_height&quot;: 948,
      &quot;revision_number&quot;: 0
    },
    &quot;max_clock_drift&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 3
    },
    &quot;trust_level&quot;: {
      &quot;denominator&quot;: &quot;3&quot;,
      &quot;numerator&quot;: &quot;1&quot;
    },
    &quot;trusting_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1209600
    },
    &quot;unbonding_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1814400
    },
    &quot;upgrade_path&quot;: [
      &quot;upgrade&quot;,
      &quot;upgradedIBCState&quot;
    ]
  }
}
</code></pre>
<h2><a class="header" href="#query-the-client-consensus-state" id="query-the-client-consensus-state">Query the client consensus state</a></h2>
<p>Use the <code>query client consensus</code> command to query the consensus state for a given client and consensus height:</p>
<pre><code class="language-shell">USAGE:
    hermes query client consensus &lt;OPTIONS&gt;

DESCRIPTION:
    Query client consensus state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query
    consensus_epoch           epoch of the client's consensus state to query
    consensus_height          height of the client's consensus state to query

FLAGS:
    -h, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client consensus ibc-1 07-tendermint-2 0 948 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;type&quot;: &quot;Tendermint&quot;,
    &quot;next_validators_hash&quot;: &quot;61B504627364047439A253FFBDD5D384B31D29611BD4B2ABA2636C232ABADA33&quot;,
    &quot;root&quot;: &quot;82EFC9F24C8B595BDADBFE1576B473648DD8EBC76F30DC21201539FCCE15A9F8&quot;,
    &quot;timestamp&quot;: &quot;2021-02-01T13:42:30.30536Z&quot;
  }
}
</code></pre>
<h2><a class="header" href="#query-the-identifiers-of-all-connections-associated-with-a-given-client" id="query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></h2>
<p>Use the <code>query client connections</code> command to query the connections associated with a given client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query client connections

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -h, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connections of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client connections ibc-0 07-terndermint-0
{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;connection-0&quot;,
    &quot;connection-1&quot;,
    &quot;connection-2&quot;
  ]
}```
</code></pre>
<h1><a class="header" href="#table-of-contents-6" id="table-of-contents-6">Table of Contents</a></h1>
<ul>
<li><a href="query_connection.html#query-connections">Query Connections</a></li>
<li><a href="query_connection.html#query-connection-data">Query Connection Data</a>
<ul>
<li><a href="query_connection.html#query-the-connection-end-data">Query the connection end data</a></li>
<li><a href="query_connection.html#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-connections" id="query-connections">Query Connections</a></h1>
<p>Use the <code>query connections</code> command to query the identifiers of all connections on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all connections on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all connections on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connections ibc-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;connection-0&quot;,
    &quot;connection-1&quot;,
    &quot;connection-2&quot;,
    &quot;connection-3&quot;
  ]
}
</code></pre>
<h1><a class="header" href="#query-connection-data" id="query-connection-data">Query Connection Data</a></h1>
<p>Use the <code>query connection</code> commands to query a specific connection.</p>
<pre><code class="language-shell">USAGE:
    hermes query connection &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about connection(s)

SUBCOMMANDS:
    end        query connection end
    channels   query connection channels
</code></pre>
<h2><a class="header" href="#query-the-connection-end-data" id="query-the-connection-end-data">Query the connection end data</a></h2>
<p>Use the <code>query connection end</code> command to query the connection end:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection end &lt;OPTIONS&gt;

DESCRIPTION:
    query connection end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connection end of connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;client_id&quot;: &quot;07-tendermint-2&quot;,
    &quot;counterparty&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-1&quot;,
      &quot;connection_id&quot;: &quot;connection-0&quot;,
      &quot;prefix&quot;: &quot;ibc&quot;
    },
    &quot;delay_period&quot;: 0,
    &quot;state&quot;: &quot;Open&quot;,
    &quot;versions&quot;: [
      {
        &quot;features&quot;: [
          &quot;ORDER_ORDERED&quot;,
          &quot;ORDER_UNORDERED&quot;
        ],
        &quot;identifier&quot;: &quot;1&quot;
      }
    ]
  }
}
</code></pre>
<h2><a class="header" href="#query-the-identifiers-of-all-channels-associated-with-a-given-connection" id="query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></h2>
<p>Use the <code>query connection channels</code> command to query the identifiers of the channels associated with a given connection:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection channels &lt;OPTIONS&gt;

DESCRIPTION:
    query connection channels

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channels associated with connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection channels ibc-1 connection-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;channel-1&quot;
  ]
}
</code></pre>
<h1><a class="header" href="#table-of-contents-7" id="table-of-contents-7">Table of Contents</a></h1>
<ul>
<li><a href="query_channel.html#query-channels">Query Channels</a></li>
<li><a href="query_channel.html#query-channel-data">Query Channel Data</a>
<ul>
<li><a href="query_channel.html#query-the-channel-end-data">Query the channel end data</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#query-channels" id="query-channels">Query Channels</a></h1>
<p>Use the <code>query channels</code> command to query the identifiers of all channels on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query channels &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all channels on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all channels on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channels ibc-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;channel-0&quot;,
    &quot;channel-1&quot;,
    &quot;channel-2&quot;,
    &quot;channel-3&quot;
  ]
}
</code></pre>
<h1><a class="header" href="#query-channel-data" id="query-channel-data">Query Channel Data</a></h1>
<p>Use the <code>query channel</code> commands to query the information about a specific channel.</p>
<pre><code class="language-shell">USAGE:
    hermes query channel &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about channels

SUBCOMMANDS:
    end        query channel end
</code></pre>
<h2><a class="header" href="#query-the-channel-end-data" id="query-the-channel-end-data">Query the channel end data</a></h2>
<p>Use the <code>query channel end</code> command to query the channel end:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel end &lt;OPTIONS&gt;

DESCRIPTION:
    Query channel end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channel end ibc-1 channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;connection_hops&quot;: [
      &quot;connection-1&quot;
    ],
    &quot;ordering&quot;: &quot;Unordered&quot;,
    &quot;remote&quot;: {
      &quot;channel_id&quot;: &quot;channel-0&quot;,
      &quot;port_id&quot;: &quot;transfer&quot;
    },
    &quot;state&quot;: &quot;Open&quot;,
    &quot;version&quot;: &quot;ics20-1&quot;
  }
}
</code></pre>
<h1><a class="header" href="#packet-queries" id="packet-queries">Packet Queries</a></h1>
<p>Use the <code>query packet</code> commands to query information about packets.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about packets

SUBCOMMANDS:
    commitments query packet commitments
    commitment query packet commitment
    acks       query packet acknowledgments
    ack        query packet acknowledgment
    unreceived-packets query unreceived packets
    unreceived-acks query unreceived acknowledgments
</code></pre>
<h2><a class="header" href="#table-of-contents-8" id="table-of-contents-8">Table of Contents</a></h2>
<ul>
<li><a href="query_packet.html#packet-commitments">Packet Commitments</a></li>
<li><a href="query_packet.html#packet-commitment-with-sequence">Packet Commitment with Sequence</a></li>
<li><a href="query_packet.html#packet-acknowledgments">Packet Acknowledgments</a></li>
<li><a href="query_packet.html#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></li>
<li><a href="query_packet.html#unreceived-packets">Unreceived Packets</a></li>
<li><a href="query_packet.html#unreceived-acknowledgments">Unreceived Acknowledgments</a></li>
</ul>
<h2><a class="header" href="#packet-commitments" id="packet-commitments">Packet Commitments</a></h2>
<p>Use the <code>query packet commitments</code> command to query the sequence numbers of all packets that have been sent but not yet acknowledged (these are the packets that still have their commitments stored).</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitments &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets that still have commitments on <code>ibc-0</code> and that were sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitments ibc-0 transfer channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;height&quot;: {
      &quot;revision_height&quot;: 139,
      &quot;revision_number&quot;: 0
    },
    &quot;seqs&quot;: [
      1,
      2,
      3
    ]
  }
}
</code></pre>
<h2><a class="header" href="#packet-commitment-with-sequence" id="packet-commitment-with-sequence">Packet Commitment with Sequence</a></h2>
<p>Use the <code>query packet commitment</code> command to query the commitment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitment &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the commitment of packet with sequence <code>3</code> sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitment ibc-0 transfer channel-0 3 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: &quot;F9458DC7EBEBCD6D18E983FCAB5BD752CC2A74532BBD50B812DB229997739EFC&quot;
}
</code></pre>
<h2><a class="header" href="#packet-acknowledgments" id="packet-acknowledgments">Packet Acknowledgments</a></h2>
<p>Use the <code>query packet acknowledgments</code> command to query the sequence numbers of all packets that have been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets acknowledged that were received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet acks ibc-1 transfer channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;height&quot;: {
      &quot;revision_height&quot;: 397,
      &quot;revision_number&quot;: 1
    },
    &quot;seqs&quot;: [
      1,
      2,
      3
    ]
  }
}
</code></pre>
<h2><a class="header" href="#packet-acknowledgment-with-sequence" id="packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></h2>
<p>Use the <code>query packet acknowledgment</code> command to query the acknowledgment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet ack &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -h, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the acknowledgment of packet with sequence <code>2</code> received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet ack ibc-1 transfer channel-1 2 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: &quot;08F7557ED51826FE18D84512BF24EC75001EDBAF2123A477DF72A0A9F3640A7C&quot;
}
</code></pre>
<h2><a class="header" href="#unreceived-packets" id="unreceived-packets">Unreceived Packets</a></h2>
<p>Use the <code>query packet unreceived-packets</code> command to query the sequence numbers of all packets that have been sent on the source chain but not yet received on the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-packets &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the chain to query the unreceived sequences
    src_chain_id              identifier of the chain where sent sequences are queried
    src_port_id               identifier of the port to query on source chain
    src_channel_id            identifier of the channel to query on source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets sent on <code>ibc-0</code> on <code>transfer</code> port and <code>channel-0</code> but not yet received:</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 ibc-0 transfer channel-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    1,
    2,
    3
  ]
}
</code></pre>
<h2><a class="header" href="#unreceived-acknowledgments" id="unreceived-acknowledgments">Unreceived Acknowledgments</a></h2>
<p>Use the <code>query packet unreceived-acks</code> command to query the sequence numbers of all packets that have been received by the source chain but not yet acknowledged by the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived acknowledgments

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the chain to query the unreceived acknowledgments
    src_chain_id              identifier of the chain where received sequences are queried
    src_port_id               identifier of the port to query on source chain
    src_channel_id            identifier of the channel to query on source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets received on <code>ibc-1</code> on <code>transfer</code> port and <code>channel-1</code> but not yet acknowledged on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet unreceived-acks ibc-0 ibc-1 transfer channel-1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    1,
    2,
    3
  ]
}
</code></pre>
<h1><a class="header" href="#relayer-listen-mode" id="relayer-listen-mode">Relayer Listen Mode</a></h1>
<p>The relayer can be started in <code>listen</code> mode to display the events emitted by a given chain. <code>NewBlock</code> and IBC events are shown.</p>
<pre><code class="language-shell">USAGE:
    hermes listen &lt;OPTIONS&gt;

DESCRIPTION:
    Listen to IBC events

POSITIONAL ARGUMENTS:
    chain_id
</code></pre>
<p><strong>Example</strong></p>
<p>Start the relayer in listen mode for <code>ibc-0</code> events and observe the output:</p>
<pre><code class="language-shell">hermes listen ibc-0

[relayer-cli/src/commands/listen.rs:45] event_batch = EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10914),
    events: [
        NewBlock(
            NewBlock {
                height: block::Height(10914),
            },
        ),
    ],
}
[relayer-cli/src/commands/listen.rs:45] event_batch = EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10915),
    events: [
        OpenInitConnection(
            OpenInit(
                Attributes {
                    height: block::Height(10915),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: None,
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],
...
[relayer-cli/src/commands/listen.rs:45] event_batch = EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10919),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10919),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision_number: 1,
                        revision_height: 10907,
                    },
                },
            ),
        ),
    ],
}
...
[relayer-cli/src/commands/listen.rs:45] event_batch = EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10924),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10924),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision_number: 1,
                        revision_height: 10912,
                    },
                },
            ),
        ),
        OpenAckConnection(
            OpenAck(
                Attributes {
                    height: block::Height(10924),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: Some(
                        ConnectionId(
                            &quot;connection-5&quot;,
                        ),
                    ),
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],
}
</code></pre>
<h1><a class="header" href="#help" id="help">Help</a></h1>
<p>This section provides guidelines regarding troubleshooting and general
resources for getting help with <code>hermes</code>.
For this purpose, we recommend a few ideas that could be of help:</p>
<ul>
<li><a href="./help.html#profiling">profile</a> your relayer binary to identify slow methods;</li>
<li><a href="./help.html#parametrizing-the-log-output-level">configure</a> the <code>log_level</code> to help with debugging;</li>
<li><a href="./help.html#patching-gaia">patch</a> your local gaia chain(s) to enable some corner-case methods
(e.g., channel close);</li>
</ul>
<p>And if the above options do not address your specific problem:</p>
<ul>
<li>you can <a href="./help.html#new-feature-request">request a new feature</a>;</li>
<li>or consult the <a href="https://github.com/informalsystems/ibc-rs/issues">list of reported issues</a> and search by relevant
keywords to see if you're dealing with a known problem;</li>
<li>we would be grateful if you can submit a <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=bug-report.md">bug report</a>
discussing any problem you find, and from there on we can look at the
problem together;</li>
</ul>
<p>Lastly, for general questions, you can reach us at <code>hello@informal.systems</code>,
or on Twitter <a href="https://twitter.com/informalinc">@informalinc</a>.</p>
<h2><a class="header" href="#profiling" id="profiling">Profiling</a></h2>
<p>The <code>relayer</code> crate provides a <code>time!</code> macro which can be used to measure how much time is spent between the invocation of the macro and the end of the enclosing scope.</p>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>The <code>time!</code> macro has no effect unless the <code>profiling</code> feature of the <code>relayer</code> crate is enabled.</p>
<p>To enable it, one must compile the <code>relayer-cli</code> crate with the <code>--features=profiling</code> flag.</p>
<p>a) One way is to build the <code>relayer</code> binary and update the <code>hermes</code> alias to point to the executable:</p>
<pre><code class="language-shellscript">cd relayer-cli/
cargo build --features=profiling
</code></pre>
<p>b) Alternatively, one can use the <code>cargo run</code> command and update the alias accordingly:</p>
<pre><code class="language-shellscript">alias hermes='cargo run --features=profiling --manifest-path=relayer-cli/Cargo.toml --'
</code></pre>
<p>The <code>--manifest-path=relayer-cli/Cargo.toml</code> flag is needed for <code>cargo run</code> to accept the <code>--features</code> flag.</p>
<h3><a class="header" href="#example-3" id="example-3">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function(x: u32) -&gt; u32 {
    time!(&quot;myfunction: x={}&quot;, x); // A

    std::thread::sleep(Duration::from_secs(1));

    {
        time!(&quot;inner operation&quot;); // B

        std::thread::sleep(Duration::from_secs(2));

        // timer B ends here
    }

    x + 1

    // timer A ends here
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#output" id="output">Output</a></h4>
<pre><code>Jan 20 11:28:46.841  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - start
Jan 20 11:28:47.842  INFO relayer::macros::profiling:    ⏳ inner operation - start
Jan 20 11:28:49.846  INFO relayer::macros::profiling:    ⏳ inner operation - elapsed: 2004ms
Jan 20 11:28:49.847  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - elapsed: 3005ms
</code></pre>
<p>Profiling is useful for tracking down unusually slow methods.
Each transaction or query usually consists of multiple lower-level methods,
and it's often not clear which of these are the culprit for low performance.
With profiling enabled, <code>hermes</code> will output timing information for individual
methods involved in a command.</p>
<p><strong>NOTE</strong>: To be able to see the profiling output, the
<a href="./help.html#parametrizing-the-log-output-level">log level</a> should be <code>info</code>
level or lower.</p>
<h4><a class="header" href="#example-output-for-tx-raw-conn-init-command" id="example-output-for-tx-raw-conn-init-command">Example output for <code>tx raw conn-init</code> command</a></h4>
<pre><code>hermes -c config_example.toml tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-0
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.282&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_light_client - start&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.361&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_light_client - elapsed: 75ms&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.361&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_event_monitor - start&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.374&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_event_monitor - elapsed: 12ms&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.374&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-1&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.375&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_light_client - start&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.405&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_light_client - elapsed: 29ms&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.405&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_event_monitor - start&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.408&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;⏳ init_event_monitor - elapsed: 3ms&quot;},&quot;target&quot;:&quot;ibc_relayer::macros::profiling&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.408&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-0&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;timestamp&quot;:&quot;Feb 03 14:46:55.410&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Message ConnOpenInit: Connection { a_side: ConnectionSide { chain: ProdChainHandle { chain_id: ChainId { id: \&quot;ibc-1\&quot;, version: 1 }, runtime_sender: Sender { .. } }, client_id: ClientId(\&quot;07-tendermint-0\&quot;), connection_id: ConnectionId(\&quot;defaultConnection\&quot;) }, b_side: ConnectionSide { chain: ProdChainHandle { chain_id: ChainId { id: \&quot;ibc-0\&quot;, version: 0 }, runtime_sender: Sender { .. } }, client_id: ClientId(\&quot;07-tendermint-0\&quot;), connection_id: ConnectionId(\&quot;defaultConnection\&quot;) } }&quot;},&quot;target&quot;:&quot;ibc_relayer_cli::commands::tx::connection&quot;}

</code></pre>
<h2><a class="header" href="#parametrizing-the-log-output-level" id="parametrizing-the-log-output-level">Parametrizing the log output level</a></h2>
<p>The relayer configuration file permits parametrization of output verbosity via the knob called <code>log_level</code>.
This file is loaded by default from <code>$HOME/.hermes/config.toml</code>, but can be overridden in all commands
with the <code>-c</code> flag, eg. <code>hermes -c ./path/to/my/config.toml some command</code>.</p>
<p>Relevant snippet:</p>
<pre><code class="language-toml">[global]
timeout = '10s'
strategy = 'naive'
log_level = 'error'
</code></pre>
<p>Valid options for <code>log_level</code> are: 'error', 'warn', 'info', 'debug', 'trace'.
These levels correspond to the tracing sub-component of the relayer-cli, <a href="https://docs.rs/tracing-core/0.1.17/tracing_core/struct.Level.html">see
here</a>.</p>
<p>The relayer will <em>always</em> print a last line summarizing the result of its
operation for queries of transactions. In addition to  this last line,
arbitrary debug, info, or other outputs may be produced.  Example, with
<code>log_level = 'debug'</code>:</p>
<pre><code class="language-bash">Running `target/debug/relayer query client consensus ibc-0 07-tendermint-X 0 1`
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.070&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: abscissa_core::terminal::component::Terminal (v0.5.2)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.071&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: relayer_cli::components::Tracing (v0.0.6)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.078&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Options QueryClientConsensusOptions { client_id: ClientId(\&quot;07-tendermint-X\&quot;), revision_number: 0, revision_height: 1, height: 0, proof: true }&quot;},&quot;target&quot;:&quot;relayer_cli::commands::query::client&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.080&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;resolving host=\&quot;localhost\&quot;&quot;},&quot;target&quot;:&quot;hyper::client::connect::dns&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to [::1]:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to 127.0.0.1:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<p>For the same command, with <code>log_level = 'error'</code>, just the last line will be
produced:</p>
<pre><code class="language-bash">   Running `target/debug/relayer query client consensus ibc-0 07-tendermint-X 0 1`
{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<h2><a class="header" href="#patching-gaia" id="patching-gaia">Patching <code>gaia</code></a></h2>
<p>The guide below refers specifically to patching your gaia chain so that the
relayer can initiate the closing of channels by submitting a <a href="./tx_channel_close.html#channel-close-init"><code>chan-close-init</code>
transaction</a>.
Without this modification, the transaction will be rejected.
We also describe how to test the channel closing feature.</p>
<ul>
<li>
<p>Clone the Cosmos SDK</p>
<pre><code class="language-shellscript">git clone https://github.com/cosmos/cosmos-sdk.git ~/go/src/github.com/cosmos/cosmos-sdk
cd ~/go/src/github.com/cosmos/cosmos-sdk
</code></pre>
</li>
<li>
<p>Apply these diffs:</p>
<pre><code>   --- a/x/ibc/applications/transfer/module.go
   +++ b/x/ibc/applications/transfer/module.go
   @@ -305,7 +305,7 @@ func (am AppModule) OnChanCloseInit(
           channelID string,
    ) error {
           // Disallow user-initiated channel closing for transfer channels
   -       return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, &quot;user cannot close channel&quot;)
   +       return nil
    }
</code></pre>
</li>
<li>
<p>Append the line below (watch for the placeholder <code>&lt;your&gt;</code>) as the last line
in your <code>go.mod</code> in the gaia clone:</p>
</li>
</ul>
<p><code>replace github.com/cosmos/cosmos-sdk =&gt; /Users/&lt;your&gt;/go/src/github.com/cosmos/cosmos-sdk</code></p>
<ul>
<li>Now <code>make build</code> and <code>make install</code> your local copy of gaia</li>
</ul>
<p>In order to test the correct operation during the channel close, perform the steps below.</p>
<ul>
<li>
<p>the channel should be in state open-open:</p>
</li>
<li>
<p>transfer of 5555 samoleans from <code>ibc-1</code> to <code>ibc-0</code>. This results in a
Tx to <code>ibc-1</code> for a <code>MsgTransfer</code> packet.
Make sure you're not relaying this packet (the relayer should not be running on
this path).</p>
<pre><code class="language-shellscript">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-1 5555 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>now do the first step of channel closing: the channel will transition
to close-open:</p>
<pre><code class="language-shellscript">hermes -c config.toml tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer channel-0 channel-1
</code></pre>
</li>
<li>
<p>trigger timeout on close to ibc-1</p>
<pre><code class="language-shellscript">hermes -c config.toml tx raw packet-recv ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>close-close</p>
<pre><code class="language-shellscript">hermes -c config.toml tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer channel-1 channel-0
</code></pre>
</li>
<li>
<p>verify that the two ends are in Close state:</p>
<pre><code class="language-shellscript">hermes -c config.toml query channel end ibc-0 transfer channel-0
hermes -c config.toml query channel end ibc-1 transfer channel-1
</code></pre>
</li>
</ul>
<h2><a class="header" href="#new-feature-request" id="new-feature-request">New Feature Request</a></h2>
<p>If you would like a feature to be added to <code>hermes</code>, don't hesitate
to open a discussion about that via the <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=feature-request.md">feature request</a>
issue template.</p>
<blockquote>
<p>Note that Hermes is packaged as part of the <code>ibc-relayer-cli</code> crate.</p>
</blockquote>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>These are some of the definitions used in this guide: </p>
<table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td>IBC transaction</td><td>A transaction that includes IBC datagrams (including packets). This is constructed by the relayer and sent over the physical network to a chain according to the chain rules. For example, for tendermint chains a broadcast_tx_commit request is sent to a tendermint RPC server.</td></tr>
<tr><td>IBC datagram</td><td>An element of the transaction payload sent by the relayer; it includes client, connection, channel and IBC packet data. Multiple IBC datagrams may be included in an IBC transaction.</td></tr>
<tr><td>IBC packet</td><td>A particular type of IBC datagram that includes the application packet and its commitment proof.</td></tr>
<tr><td>IBC Client</td><td>Client code running on chain, typically only the light client verification related functionality.</td></tr>
<tr><td>Relayer Light Client</td><td>Full light client functionality, including connecting to at least one provider (full node), storing and verifying headers, etc.</td></tr>
<tr><td>Source chain</td><td>The chain from which the relayer reads data to fill an IBC datagram.</td></tr>
<tr><td>Destination chain</td><td>The chain where the relayer submits transactions that include the IBC datagram.</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
